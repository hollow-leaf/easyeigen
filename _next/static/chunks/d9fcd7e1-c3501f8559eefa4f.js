"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{52325:function(e,t,a){var i=a(42223),n=a(80496),r=a(67060);a(67462);var o=a(42474),l=a(67172),s=a(95131),u=a(4285),f=a(37083),d=a(91094);function c(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach(function(a){if("default"!==a){var i=Object.getOwnPropertyDescriptor(e,a);Object.defineProperty(t,a,i.get?i:{enumerable:!0,get:function(){return e[a]}})}}),t.default=e,Object.freeze(t)}var g=h(i),w=c(r),m=c(o),b=h(l),p=c(f),v=c(d);let y=n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),S=n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),C=n.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),F=n.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function E(e){let t;if(n.Scalar.eq(e,F))t=await n.buildBn128();else if(n.Scalar.eq(e,C))t=await n.buildBls12381();else throw Error(`Curve not supported: ${n.Scalar.toString(e)}`);return t}async function x(e){let t;let a=e.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(a)>=0)t=await n.buildBn128();else if(["BLS12381"].indexOf(a)>=0)t=await n.buildBls12381();else throw Error(`Curve not supported: ${e}`);return t}function B(e){return((4294901760&e)!=0?(e&=4294901760,16):0)|((4278255360&e)!=0?(e&=4278255360,8):0)|((4042322160&e)!=0?(e&=4042322160,4):0)|((3435973836&e)!=0?(e&=3435973836,2):0)|(2863311530&e)!=0}function L(e,t){let a=new DataView(e.buffer,e.byteOffset,e.byteLength),i="";for(let e=0;e<4;e++){e>0&&(i+="\n"),i+="		";for(let t=0;t<4;t++)t>0&&(i+=" "),i+=a.getUint32(16*e+4*t).toString(16).padStart(8,"0")}return t&&(i=t+"\n"+i),i}function A(e,t){if(e.byteLength!=t.byteLength)return!1;for(var a=new Int8Array(e),i=new Int8Array(t),n=0;n!=e.byteLength;n++)if(a[n]!=i[n])return!1;return!0}async function _(e,t,a,i,n){if(e.G1.isZero(t)||e.G1.isZero(a)||e.G2.isZero(i)||e.G2.isZero(n))return!1;let r=await e.pairingEq(t,n,e.G1.neg(a),i);return r}function T(e){let t=new Uint8Array(e);return void 0!==globalThis.crypto?globalThis.crypto.getRandomValues(t):m.default.randomFillSync(t),t}async function z(e){if(void 0===globalThis.crypto||void 0===globalThis.crypto.subtle)return m.default.createHash("sha256").update(e).digest();{let t=await globalThis.crypto.subtle.digest("SHA-256",e.buffer);return new Uint8Array(t)}}function R(e,t){return new DataView(e.buffer).getUint32(t,!1)}async function P(e){for(;!e;)e=await window.prompt("Enter a random text. (Entropy): ","");let t=w.default(64);t.update(T(64));let a=new TextEncoder;t.update(a.encode(e));let i=t.digest(),r=[];for(let e=0;e<8;e++)r[e]=R(i,4*e);let o=new n.ChaCha(r);return o}async function G(e,t){let a,i;t<32?(a=1<<t>>>0,i=1):(a=4294967296,i=1<<t-32>>>0);let r=e;for(let e=0;e<i;e++)for(let e=0;e<a;e++)r=await z(r);let o=new DataView(r.buffer,r.byteOffset,r.byteLength),l=[];for(let e=0;e<8;e++)l[e]=o.getUint32(4*e,!1);let s=new n.ChaCha(l);return s}async function U(e,t){await g.startWriteSection(e,1),await e.writeULE32(1),await g.endWriteSection(e);let a=await E(t.q);await g.startWriteSection(e,2);let i=a.q,r=(Math.floor((n.Scalar.bitLength(i)-1)/64)+1)*8,o=a.r,l=(Math.floor((n.Scalar.bitLength(o)-1)/64)+1)*8;await e.writeULE32(r),await g.writeBigInt(e,i,r),await e.writeULE32(l),await g.writeBigInt(e,o,l),await e.writeULE32(t.nVars),await e.writeULE32(t.nPublic),await e.writeULE32(t.domainSize),await I(e,a,t.vk_alpha_1),await I(e,a,t.vk_beta_1),await O(e,a,t.vk_beta_2),await O(e,a,t.vk_gamma_2),await I(e,a,t.vk_delta_1),await O(e,a,t.vk_delta_2),await g.endWriteSection(e)}async function I(e,t,a){let i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprLEM(i,0,a),await e.write(i)}async function O(e,t,a){let i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprLEM(i,0,a),await e.write(i)}async function k(e,t,a){let i=await e.read(2*t.G1.F.n8),n=t.G1.fromRprLEM(i,0);return a?t.G1.toObject(n):n}async function q(e,t,a){let i=await e.read(2*t.G2.F.n8),n=t.G2.fromRprLEM(i,0);return a?t.G2.toObject(n):n}async function $(e,t,a){await g.startReadUniqueSection(e,t,1);let i=await e.readULE32();if(await g.endReadSection(e),1===i)return await Q(e,t,a);if(2===i)return await M(e,t,a);if(10===i)return await Z(e,t,a);throw Error("Protocol not supported: ")}async function Q(e,t,a){let i={};i.protocol="groth16",await g.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await g.readBigInt(e,n);let r=await e.readULE32();return i.n8r=r,i.r=await g.readBigInt(e,r),i.curve=await E(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=B(i.domainSize),i.vk_alpha_1=await k(e,i.curve,a),i.vk_beta_1=await k(e,i.curve,a),i.vk_beta_2=await q(e,i.curve,a),i.vk_gamma_2=await q(e,i.curve,a),i.vk_delta_1=await k(e,i.curve,a),i.vk_delta_2=await q(e,i.curve,a),await g.endReadSection(e),i}async function M(e,t,a){let i={};i.protocol="plonk",await g.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await g.readBigInt(e,n);let r=await e.readULE32();return i.n8r=r,i.r=await g.readBigInt(e,r),i.curve=await E(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=B(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(r),i.k2=await e.read(r),i.Qm=await k(e,i.curve,a),i.Ql=await k(e,i.curve,a),i.Qr=await k(e,i.curve,a),i.Qo=await k(e,i.curve,a),i.Qc=await k(e,i.curve,a),i.S1=await k(e,i.curve,a),i.S2=await k(e,i.curve,a),i.S3=await k(e,i.curve,a),i.X_2=await q(e,i.curve,a),await g.endReadSection(e),i}async function Z(e,t,a){let i={};i.protocol="fflonk",i.protocolId=10,await g.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await g.readBigInt(e,n),i.curve=await E(i.q);let r=await e.readULE32();return i.n8r=r,i.r=await g.readBigInt(e,r),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=B(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(r),i.k2=await e.read(r),i.w3=await e.read(r),i.w4=await e.read(r),i.w8=await e.read(r),i.wr=await e.read(r),i.X_2=await q(e,i.curve,a),i.C0=await k(e,i.curve,a),await g.endReadSection(e),i}async function V(e,t){let{fd:a,sections:i}=await g.readBinFile(e,"zkey",1),r=await $(a,i,t),o=new n.F1Field(r.r),l=n.Scalar.mod(n.Scalar.shl(1,8*r.n8r),r.r),s=o.inv(l),u=o.mul(s,s),f=await E(r.q);await g.startReadUniqueSection(a,i,3),r.IC=[];for(let e=0;e<=r.nPublic;e++){let e=await k(a,f,t);r.IC.push(e)}await g.endReadSection(a),await g.startReadUniqueSection(a,i,4);let d=await a.readULE32();r.ccoefs=[];for(let e=0;e<d;e++){let e=await a.readULE32(),t=await a.readULE32(),i=await a.readULE32(),n=await c();r.ccoefs.push({matrix:e,constraint:t,signal:i,value:n})}await g.endReadSection(a),await g.startReadUniqueSection(a,i,5),r.A=[];for(let e=0;e<r.nVars;e++){let i=await k(a,f,t);r.A[e]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,6),r.B1=[];for(let e=0;e<r.nVars;e++){let i=await k(a,f,t);r.B1[e]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,7),r.B2=[];for(let e=0;e<r.nVars;e++){let i=await q(a,f,t);r.B2[e]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,8),r.C=[];for(let e=r.nPublic+1;e<r.nVars;e++){let i=await k(a,f,t);r.C[e]=i}await g.endReadSection(a),await g.startReadUniqueSection(a,i,9),r.hExps=[];for(let e=0;e<r.domainSize;e++){let e=await k(a,f,t);r.hExps.push(e)}return await g.endReadSection(a),await a.close(),r;async function c(){let e=await g.readBigInt(a,r.n8r);return o.mul(e,u)}}async function W(e,t,a){let i={delta:{}};i.deltaAfter=await k(e,t,a),i.delta.g1_s=await k(e,t,a),i.delta.g1_sx=await k(e,t,a),i.delta.g2_spx=await q(e,t,a),i.transcript=await e.read(64),i.type=await e.readULE32();let n=await e.readULE32(),r=e.pos,o=0;for(;e.pos-r<n;){let t=await e.read(1);if(t[0]<=o)throw Error("Parameters in the contribution must be sorted");if(o=t[0],1==t[0]){let t=await e.read(1),a=await e.read(t[0]);i.name=new TextDecoder().decode(a)}else if(2==t[0]){let t=await e.read(1);i.numIterationsExp=t[0]}else if(3==t[0]){let t=await e.read(1);i.beaconHash=await e.read(t[0])}else throw Error("Parameter not recognized")}if(e.pos!=r+n)throw Error("Parametes do not match");return i}async function j(e,t,a){await g.startReadUniqueSection(e,a,10);let i={contributions:[]};i.csHash=await e.read(64);let n=await e.readULE32();for(let a=0;a<n;a++){let a=await W(e,t);i.contributions.push(a)}return await g.endReadSection(e),i}async function N(e,t,a){await I(e,t,a.deltaAfter),await I(e,t,a.delta.g1_s),await I(e,t,a.delta.g1_sx),await O(e,t,a.delta.g2_spx),await e.write(a.transcript),await e.writeULE32(a.type||0);let i=[];if(a.name){i.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));i.push(e.byteLength);for(let t=0;t<e.byteLength;t++)i.push(e[t])}if(1==a.type){i.push(2),i.push(a.numIterationsExp),i.push(3),i.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)i.push(a.beaconHash[e])}if(i.length>0){let t=new Uint8Array(i);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0)}async function D(e,t,a){await g.startWriteSection(e,10),await e.write(a.csHash),await e.writeULE32(a.contributions.length);for(let i=0;i<a.contributions.length;i++)await N(e,t,a.contributions[i]);await g.endWriteSection(e)}function H(e,t,a){let i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprUncompressed(i,0,a),e.update(i)}function K(e,t,a){H(e,t,a.deltaAfter),H(e,t,a.delta.g1_s),H(e,t,a.delta.g1_sx),function(e,t,a){let i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprUncompressed(i,0,a),e.update(i)}(e,t,a.delta.g2_spx),e.update(a.transcript)}async function X(e,t,a){await g.startWriteSection(e,1);let i=(Math.floor((n.Scalar.bitLength(a)-1)/64)+1)*8;if(await e.writeULE32(i),await g.writeBigInt(e,a,i),t.byteLength%i!=0)throw Error("Invalid witness length");await e.writeULE32(t.byteLength/i),await g.endWriteSection(e),await g.startWriteSection(e,2),await e.write(t),await g.endWriteSection(e)}async function Y(e,t){await g.startReadUniqueSection(e,t,1);let a=await e.readULE32(),i=await g.readBigInt(e,a),n=await e.readULE32();return await g.endReadSection(e),{n8:a,q:i,nWitness:n}}let{stringifyBigInts:J}=n.utils;async function ee(e,t,a){let{fd:i,sections:r}=await g.readBinFile(t,"wtns",2,33554432,8388608),o=await Y(i,r),{fd:l,sections:s}=await g.readBinFile(e,"zkey",2,33554432,8388608),u=await $(l,s);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}`);let f=u.curve,d=f.Fr,c=f.G1,h=f.G2,w=B(u.domainSize);a&&a.debug("Reading Wtns");let m=await g.readSection(i,r,2);a&&a.debug("Reading Coeffs");let b=await g.readSection(l,s,4);a&&a.debug("Building ABC");let[p,v,y]=await et(f,u,m,b,a),S=w==d.s?f.Fr.shift:f.Fr.w[w+1],C=await d.ifft(p,"","",a,"IFFT_A"),F=await d.batchApplyKey(C,d.e(1),S),E=await d.fft(F,"","",a,"FFT_A"),x=await d.ifft(v,"","",a,"IFFT_B"),L=await d.batchApplyKey(x,d.e(1),S),A=await d.fft(L,"","",a,"FFT_B"),_=await d.ifft(y,"","",a,"IFFT_C"),T=await d.batchApplyKey(_,d.e(1),S),z=await d.fft(T,"","",a,"FFT_C");a&&a.debug("Join ABC");let R=await ea(f,u,E,A,z,a),P={};a&&a.debug("Reading A Points");let G=await g.readSection(l,s,5);P.pi_a=await f.G1.multiExpAffine(G,m,a,"multiexp A"),a&&a.debug("Reading B1 Points");let U=await g.readSection(l,s,6),I=await f.G1.multiExpAffine(U,m,a,"multiexp B1");a&&a.debug("Reading B2 Points");let O=await g.readSection(l,s,7);P.pi_b=await f.G2.multiExpAffine(O,m,a,"multiexp B2"),a&&a.debug("Reading C Points");let k=await g.readSection(l,s,8);P.pi_c=await f.G1.multiExpAffine(k,m.slice((u.nPublic+1)*f.Fr.n8),a,"multiexp C"),a&&a.debug("Reading H Points");let q=await g.readSection(l,s,9),Q=await f.G1.multiExpAffine(q,R,a,"multiexp H"),M=f.Fr.random(),Z=f.Fr.random();P.pi_a=c.add(P.pi_a,u.vk_alpha_1),P.pi_a=c.add(P.pi_a,c.timesFr(u.vk_delta_1,M)),P.pi_b=h.add(P.pi_b,u.vk_beta_2),P.pi_b=h.add(P.pi_b,h.timesFr(u.vk_delta_2,Z)),I=c.add(I,u.vk_beta_1),I=c.add(I,c.timesFr(u.vk_delta_1,Z)),P.pi_c=c.add(P.pi_c,Q),P.pi_c=c.add(P.pi_c,c.timesFr(P.pi_a,Z)),P.pi_c=c.add(P.pi_c,c.timesFr(I,M)),P.pi_c=c.add(P.pi_c,c.timesFr(u.vk_delta_1,d.neg(d.mul(M,Z))));let V=[];for(let e=1;e<=u.nPublic;e++){let t=m.slice(e*d.n8,e*d.n8+d.n8);V.push(n.Scalar.fromRprLE(t))}return P.pi_a=c.toObject(c.toAffine(P.pi_a)),P.pi_b=h.toObject(h.toAffine(P.pi_b)),P.pi_c=c.toObject(c.toAffine(P.pi_c)),P.protocol="groth16",P.curve=f.name,await l.close(),await i.close(),{proof:P=J(P),publicSignals:V=J(V)}}async function et(e,t,a,i,r){let o=e.Fr.n8,l=12+t.n8r,s=(i.byteLength-4)/l,u=new n.BigBuffer(t.domainSize*o),f=new n.BigBuffer(t.domainSize*o),d=new n.BigBuffer(t.domainSize*o),c=[u,f];for(let t=0;t<s;t++){r&&t%1e6==0&&r.debug(`QAP AB: ${t}/${s}`);let n=i.slice(4+t*l,4+t*l+l),u=new DataView(n.buffer),f=u.getUint32(0,!0),d=u.getUint32(4,!0),h=u.getUint32(8,!0),g=n.slice(12,12+o);c[f].set(e.Fr.add(c[f].slice(d*o,d*o+o),e.Fr.mul(g,a.slice(h*o,h*o+o))),d*o)}for(let a=0;a<t.domainSize;a++)r&&a%1e6==0&&r.debug(`QAP C: ${a}/${t.domainSize}`),d.set(e.Fr.mul(u.slice(a*o,a*o+o),f.slice(a*o,a*o+o)),a*o);return[u,f,d]}async function ea(e,t,a,i,r,o){let l;let s=e.Fr.n8,u=Math.floor(a.byteLength/e.Fr.n8),f=[];for(let t=0;t<u;t+=4194304){o&&o.debug(`JoinABC: ${t}/${u}`);let n=Math.min(u-t,4194304),l=[],d=a.slice(t*s,(t+n)*s),c=i.slice(t*s,(t+n)*s),h=r.slice(t*s,(t+n)*s);l.push({cmd:"ALLOCSET",var:0,buff:d}),l.push({cmd:"ALLOCSET",var:1,buff:c}),l.push({cmd:"ALLOCSET",var:2,buff:h}),l.push({cmd:"ALLOC",var:3,len:n*s}),l.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:n},{var:3}]}),l.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:n},{var:3}]}),l.push({cmd:"GET",out:0,var:3,len:n*s}),f.push(e.tm.queueAction(l))}let d=await Promise.all(f);l=a instanceof n.BigBuffer?new n.BigBuffer(a.byteLength):new Uint8Array(a.byteLength);let c=0;for(let e=0;e<d.length;e++)l.set(d[e][0],c),c+=d[e][0].byteLength;return l}let{unstringifyBigInts:ei}=n.utils;async function en(e,t,a,i){let n=ei(e),r=await b.readExisting(t),o=await r.read(r.totalSize);await r.close();let l=await s.WitnessCalculatorBuilder(o);if(1==l.circom_version()){let e=await l.calculateBinWitness(n),t=await g.createBinFile(a,"wtns",2,2);await X(t,e,l.prime),await t.close()}else{let e=await b.createOverride(a),t=await l.calculateWTNSBin(n);await e.write(t),await e.close()}}let{unstringifyBigInts:er}=n.utils;async function eo(e,t,a,i){let n=er(e),r={type:"mem"};return await en(n,t,r),await ee(a,r,i)}let{unstringifyBigInts:el}=n.utils;async function es(e,t,a,i){let r=el(e),o=el(a),l=el(t),s=await x(r.curve),u=s.G1.fromObject(r.IC[0]),f=new Uint8Array(2*s.G1.F.n8*l.length),d=new Uint8Array(s.Fr.n8*l.length);if(!function(e,t){for(let a=0;a<t.length;a++)if(!n.Scalar.lt(t[a],e.r))return!1;return!0}(s,l))return i&&i.error("Public inputs are not valid."),!1;for(let e=0;e<l.length;e++){let t=s.G1.fromObject(r.IC[e+1]);f.set(t,e*s.G1.F.n8*2),n.Scalar.toRprLE(d,s.Fr.n8*e,l[e],s.Fr.n8)}let c=await s.G1.multiExpAffine(f,d);c=s.G1.add(c,u);let h=s.G1.fromObject(o.pi_a),g=s.G2.fromObject(o.pi_b),w=s.G1.fromObject(o.pi_c);if(!function(e,t){let a=e.G1,i=e.G2;return a.isValid(t.pi_a)&&i.isValid(t.pi_b)&&a.isValid(t.pi_c)}(s,{pi_a:h,pi_b:g,pi_c:w}))return i&&i.error("Proof commitments are not valid."),!1;let m=s.G2.fromObject(r.vk_gamma_2),b=s.G2.fromObject(r.vk_delta_2),p=s.G1.fromObject(r.vk_alpha_1),v=s.G2.fromObject(r.vk_beta_2),y=await s.pairingEq(s.G1.neg(h),g,c,m,w,b,p,v);return y?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}let{unstringifyBigInts:eu}=n.utils;function ef(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return`"0x${t}"`}var ed=Object.freeze({__proto__:null,fullProve:eo,prove:ee,verify:es,exportSolidityCallData:async function(e,t){let a=eu(e),i=eu(t),n="";for(let e=0;e<i.length;e++)""!=n&&(n+=","),n+=ef(i[e]);return`[${ef(a.pi_a[0])}, ${ef(a.pi_a[1])}],[[${ef(a.pi_b[0][1])}, ${ef(a.pi_b[0][0])}],[${ef(a.pi_b[1][1])}, ${ef(a.pi_b[1][0])}]],[${ef(a.pi_c[0])}, ${ef(a.pi_c[1])}],[${n}]`}});function ec(e,t){let a=new DataView(t.buffer,t.byteOffset,t.byteLength),i=[];for(let e=0;e<8;e++)i[e]=a.getUint32(4*e);let r=new n.ChaCha(i),o=e.G2.fromRng(r);return o}function eh(e,t,a,i,n){let r=w.default(64),o=new Uint8Array([t]);r.update(o),r.update(a);let l=e.G1.toUncompressed(i);r.update(l);let s=e.G1.toUncompressed(n);r.update(s);let u=r.digest();return ec(e,u)}function eg(e,t,a,i,n){return e.g1_s=t.G1.toAffine(t.G1.fromRng(n)),e.g1_sx=t.G1.toAffine(t.G1.timesFr(e.g1_s,e.prvKey)),e.g2_sp=t.G2.toAffine(eh(t,a,i,e.g1_s,e.g1_sx)),e.g2_spx=t.G2.toAffine(t.G2.timesFr(e.g2_sp,e.prvKey)),e}async function ew(e,t){if(!t[1])throw Error(e.fileName+": File has no  header");if(t[1].length>1)throw Error(e.fileName+": File has more than one header");e.pos=t[1][0].p;let a=await e.readULE32(),i=await e.read(a),r=n.Scalar.fromRprLE(i),o=await E(r);if(8*o.F1.n64!=a)throw Error(e.fileName+": Invalid size");let l=await e.readULE32(),s=await e.readULE32();if(e.pos-t[1][0].p!=t[1][0].size)throw Error("Invalid PTau header size");return{curve:o,power:l,ceremonyPower:s}}async function em(e,t,a){let i=await e.read(12*t.F1.n8+6*t.F2.n8);return function(e,t,a,i){let n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=r(),n.tau.g1_sx=r(),n.alpha.g1_s=r(),n.alpha.g1_sx=r(),n.beta.g1_s=r(),n.beta.g1_sx=r(),n.tau.g2_spx=o(),n.alpha.g2_spx=o(),n.beta.g2_spx=o(),n;function r(){let n;return n=i?a.G1.fromRprLEM(e,t):a.G1.fromRprUncompressed(e,t),t+=2*a.G1.F.n8,n}function o(){let n;return n=i?a.G2.fromRprLEM(e,t):a.G2.fromRprUncompressed(e,t),t+=2*a.G2.F.n8,n}}(i,0,t,a)}function eb(e,t,a,i,n){async function r(i){n?a.G1.toRprLEM(e,t,i):a.G1.toRprUncompressed(e,t,i),t+=2*a.F1.n8}async function o(i){n?a.G2.toRprLEM(e,t,i):a.G2.toRprUncompressed(e,t,i),t+=2*a.F2.n8}return r(i.tau.g1_s),r(i.tau.g1_sx),r(i.alpha.g1_s),r(i.alpha.g1_sx),r(i.beta.g1_s),r(i.beta.g1_sx),o(i.tau.g2_spx),o(i.alpha.g2_spx),o(i.beta.g2_spx),e}async function ep(e,t,a,i){let n=new Uint8Array(12*t.F1.n8+6*t.F2.n8);eb(n,0,t,a,i),await e.write(n)}async function ev(e,t){let a={};a.tauG1=await s(),a.tauG2=await u(),a.alphaG1=await s(),a.betaG1=await s(),a.betaG2=await u(),a.key=await em(e,t,!0),a.partialHash=await e.read(216),a.nextChallenge=await e.read(64),a.type=await e.readULE32();let i=new Uint8Array(12*t.G1.F.n8+6*t.G2.F.n8);eb(i,0,t,a.key,!1);let n=w.default(64);n.setPartialHash(a.partialHash),n.update(i),a.responseHash=n.digest();let r=await e.readULE32(),o=e.pos,l=0;for(;e.pos-o<r;){let e=await f(1);if(e[0]<=l)throw Error("Parameters in the contribution must be sorted");if(l=e[0],1==e[0]){let e=await f(1),t=await f(e[0]);a.name=new TextDecoder().decode(t)}else if(2==e[0]){let e=await f(1);a.numIterationsExp=e[0]}else if(3==e[0]){let e=await f(1);a.beaconHash=await f(e[0])}else throw Error("Parameter not recognized")}if(e.pos!=o+r)throw Error("Parametes do not match");return a;async function s(){let a=await e.read(2*t.G1.F.n8);return t.G1.fromRprLEM(a)}async function u(){let a=await e.read(2*t.G2.F.n8);return t.G2.fromRprLEM(a)}async function f(t){let a=await e.read(t);return new Uint8Array(a)}}async function ey(e,t,a){let i=new Uint8Array(2*t.F1.n8),n=new Uint8Array(2*t.F2.n8);await o(a.tauG1),await l(a.tauG2),await o(a.alphaG1),await o(a.betaG1),await l(a.betaG2),await ep(e,t,a.key,!0),await e.write(a.partialHash),await e.write(a.nextChallenge),await e.writeULE32(a.type||0);let r=[];if(a.name){r.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));r.push(e.byteLength);for(let t=0;t<e.byteLength;t++)r.push(e[t])}if(1==a.type){r.push(2),r.push(a.numIterationsExp),r.push(3),r.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)r.push(a.beaconHash[e])}if(r.length>0){let t=new Uint8Array(r);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0);async function o(a){t.G1.toRprLEM(i,0,a),await e.write(i)}async function l(a){t.G2.toRprLEM(n,0,a),await e.write(n)}}async function eS(e,t,a,i){let n=await G(a,i),r=function(e,t,a){let i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=e.Fr.fromRng(a),i.alpha.prvKey=e.Fr.fromRng(a),i.beta.prvKey=e.Fr.fromRng(a),eg(i.tau,e,0,t,a),eg(i.alpha,e,1,t,a),eg(i.beta,e,2,t,a),i}(e,t,n);return r}async function eC(e,t,a,i,n,r,o,l,s,u){let f=n[r],d=2*f.F.n8,c=t[i][0].size/d;await g.startReadUniqueSection(e,t,i),await g.startWriteSection(a,i);let h=o;for(let t=0;t<c;t+=65536){let i;u&&u.debug(`Applying key: ${s}: ${t}/${c}`);let r=Math.min(c-t,65536);i=await e.read(r*d),i=await f.batchApplyKey(i,h,l),await a.write(i),h=n.Fr.mul(h,n.Fr.exp(l,r))}await g.endWriteSection(a),await g.endReadSection(e)}async function eF(e,t,a,i,n,r,o,l,s,u,f){let d=i[n],c=2*d.F.n8,h=Math.floor(1048576/c),g=o;for(let n=0;n<r;n+=h){let o;f&&f.debug(`Applying key ${u}: ${n}/${r}`);let w=Math.min(r-n,h),m=await e.read(w*c),b=await d.batchUtoLEM(m),p=await d.batchApplyKey(b,g,l);o="COMPRESSED"==s?await d.batchLEMtoC(p):await d.batchLEMtoU(p),a&&a.update(o),await t.write(o),g=i.Fr.mul(g,i.Fr.exp(l,w))}}n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");let{unstringifyBigInts:eE}=n.utils,ex={get:function(e,t){return isNaN(t)?e[t]:e.getElement(t)},set:function(e,t,a){return isNaN(t)?(e[t]=a,!0):e.setElement(t,a)}};class eB{constructor(e){this.length=e||0,this.arr=Array(262144);for(let t=0;t<e;t+=262144)this.arr[t/262144]=Array(Math.min(262144,e-t));return this}push(){for(let e=0;e<arguments.length;e++)this.setElement(this.length,arguments[e])}slice(e,t){let a=Array(t-e);for(let i=e;i<t;i++)a[i-e]=this.getElement(i);return a}getElement(e){e=parseInt(e);let t=Math.floor(e/262144),a=e%262144;return this.arr[t]?this.arr[t][a]:void 0}setElement(e,t){e=parseInt(e);let a=Math.floor(e/262144);this.arr[a]||(this.arr[a]=Array(262144));let i=e%262144;return this.arr[a][i]=t,e>=this.length&&(this.length=e+1),!0}getKeys(){let e=new eL;for(let t=0;t<this.arr.length;t++)if(this.arr[t])for(let a=0;a<this.arr[t].length;a++)void 0!==this.arr[t][a]&&e.push(262144*t+a);return e}}class eL{constructor(e){let t=new eB(e),a=new Proxy(t,ex);return a}}async function eA(e,t,a,r){let o,l,s;await w.default.ready();let f=w.default(64),{fd:d,sections:c}=await i.readBinFile(t,"ptau",1,4194304,16777216),{curve:h,power:g}=await ew(d,c),{fd:m,sections:b}=await i.readBinFile(e,"r1cs",1,4194304,16777216),p=await u.readR1csHeader(m,b,!1),v=await i.createBinFile(a,"zkey",1,10,4194304,16777216),y=2*h.G1.F.n8,S=2*h.G2.F.n8;if(p.prime!=h.r)return r&&r.error("r1cs curve does not match powers of tau ceremony curve"),-1;let C=B(p.nConstraints+p.nPubInputs+p.nOutputs+1-1)+1;if(C>g)return r&&r.error(`circuit too big for this power of tau ceremony. ${p.nConstraints}*2 > 2**${g}`),-1;if(!c[12])return r&&r.error("Powers of tau is not prepared."),-1;let F=p.nOutputs+p.nPubInputs,E=2**C;await i.startWriteSection(v,1),await v.writeULE32(1),await i.endWriteSection(v),await i.startWriteSection(v,2);let x=h.q,A=(Math.floor((n.Scalar.bitLength(x)-1)/64)+1)*8,_=h.r,T=(Math.floor((n.Scalar.bitLength(_)-1)/64)+1)*8,z=n.Scalar.mod(n.Scalar.shl(1,8*T),_),R=h.Fr.e(n.Scalar.mod(n.Scalar.mul(z,z),_));await v.writeULE32(A),await i.writeBigInt(v,x,A),await v.writeULE32(T),await i.writeBigInt(v,_,T),await v.writeULE32(p.nVars),await v.writeULE32(F),await v.writeULE32(E),o=await d.read(y,c[4][0].p),await v.write(o),o=await h.G1.batchLEMtoU(o),f.update(o),l=await d.read(y,c[5][0].p),await v.write(l),l=await h.G1.batchLEMtoU(l),f.update(l),s=await d.read(S,c[6][0].p),await v.write(s),s=await h.G2.batchLEMtoU(s),f.update(s);let P=new Uint8Array(y);h.G1.toRprLEM(P,0,h.G1.g);let G=new Uint8Array(S);h.G2.toRprLEM(G,0,h.G2.g);let U=new Uint8Array(y);h.G1.toRprUncompressed(U,0,h.G1.g);let I=new Uint8Array(S);h.G2.toRprUncompressed(I,0,h.G2.g),await v.write(G),await v.write(P),await v.write(G),f.update(I),f.update(U),f.update(I),await i.endWriteSection(v),r&&r.info("Reading r1cs");let O=await i.readSection(m,b,2),k=new eL(p.nVars),q=new eL(p.nVars),$=new eL(p.nVars),Q=new eL(p.nVars-F-1),M=Array(F+1);r&&r.info("Reading tauG1");let Z=await i.readSection(d,c,12,(E-1)*y,E*y);r&&r.info("Reading tauG2");let V=await i.readSection(d,c,13,(E-1)*S,E*S);r&&r.info("Reading alphatauG1");let W=await i.readSection(d,c,14,(E-1)*y,E*y);r&&r.info("Reading betatauG1");let j=await i.readSection(d,c,15,(E-1)*y,E*y);await H(),await K(3,"G1",M,"IC"),await D(),await Y(),await K(8,"G1",Q,"C"),await K(5,"G1",k,"A"),await K(6,"G1",q,"B1"),await K(7,"G2",$,"B2");let N=f.digest();return await i.startWriteSection(v,10),await v.write(N),await v.writeULE32(0),await i.endWriteSection(v),r&&r.info(L(N,"Circuit hash: ")),await v.close(),await m.close(),await d.close(),N;async function D(){await i.startWriteSection(v,9);let e=new n.BigBuffer(E*y);if(C<h.Fr.s){let t=await i.readSection(d,c,12,(2*E-1)*y,2*E*y);for(let a=0;a<E;a++){r&&a%1e4==0&&r.debug(`spliting buffer: ${a}/${E}`);let i=t.slice((2*a+1)*y,(2*a+1)*y+y);e.set(i,a*y)}}else if(C==h.Fr.s){let t=c[12][0].p+(2**(C+1)-1)*y;await d.readToBuffer(e,0,E*y,t+E*y)}else throw r&&r.error("Circuit too big"),Error("Circuit too big for this curve");await v.write(e),await i.endWriteSection(v)}async function H(){let e=new Uint8Array(12+h.Fr.n8),t=new DataView(e.buffer),a=new Uint8Array(h.Fr.n8);h.Fr.toRprLE(a,0,h.Fr.e(1));let o=0;function l(){let e=O.slice(o,o+4);o+=4;let t=new DataView(e.buffer);return t.getUint32(0,!0)}let s=new eL;for(let e=0;e<p.nConstraints;e++){r&&e%1e4==0&&r.debug(`processing constraints: ${e}/${p.nConstraints}`);let t=l();for(let a=0;a<t;a++){let t=l(),a=o;o+=h.Fr.n8;let i=y*e,n=y*e;void 0===k[t]&&(k[t]=[]),k[t].push([0,i,a]),t<=F?(void 0===M[t]&&(M[t]=[]),M[t].push([3,n,a])):(void 0===Q[t-F-1]&&(Q[t-F-1]=[]),Q[t-F-1].push([3,n,a])),s.push([0,e,t,a])}let a=l();for(let t=0;t<a;t++){let t=l(),a=o;o+=h.Fr.n8;let i=y*e,n=S*e,r=y*e;void 0===q[t]&&(q[t]=[]),q[t].push([0,i,a]),void 0===$[t]&&($[t]=[]),$[t].push([1,n,a]),t<=F?(void 0===M[t]&&(M[t]=[]),M[t].push([2,r,a])):(void 0===Q[t-F-1]&&(Q[t-F-1]=[]),Q[t-F-1].push([2,r,a])),s.push([1,e,t,a])}let i=l();for(let t=0;t<i;t++){let t=l(),a=o;o+=h.Fr.n8;let i=y*e;t<=F?(void 0===M[t]&&(M[t]=[]),M[t].push([0,i,a])):(void 0===Q[t-F-1]&&(Q[t-F-1]=[]),Q[t-F-1].push([0,i,a]))}}for(let e=0;e<=F;e++){let t=y*(p.nConstraints+e),a=y*(p.nConstraints+e);void 0===k[e]&&(k[e]=[]),k[e].push([0,t,-1]),void 0===M[e]&&(M[e]=[]),M[e].push([3,a,-1]),s.push([0,p.nConstraints+e,e,-1])}await i.startWriteSection(v,4);let u=new n.BigBuffer(s.length*(12+h.Fr.n8)+4),f=new Uint8Array(4),d=new DataView(f.buffer);d.setUint32(0,s.length,!0),u.set(f);let c=4;for(let i=0;i<s.length;i++)r&&i%1e5==0&&r.debug(`writing coeffs: ${i}/${s.length}`),function(i){let n;t.setUint32(0,i[0],!0),t.setUint32(4,i[1],!0),t.setUint32(8,i[2],!0),n=i[3]>=0?h.Fr.fromRprLE(O.slice(i[3],i[3]+h.Fr.n8),0):h.Fr.fromRprLE(a,0);let r=h.Fr.mul(n,R);h.Fr.toRprLE(e,12,r),u.set(e,c),c+=e.length}(s[i]);await v.write(u),await i.endWriteSection(v)}async function K(e,t,a,n){let o=h[t];et(a.length),await i.startWriteSection(v,e);let l=[],s=0;for(;s<a.length;){let e=0;for(;s<a.length&&e<h.tm.concurrency;){r&&r.debug(`Writing points start ${n}: ${s}/${a.length}`);let i=1,o=a[s]?a[s].length:0;for(;s+i<a.length&&o+(a[s+i]?a[s+i].length:0)<32768&&i<32768;)o+=a[s+i]?a[s+i].length:0,i++;let u=a.slice(s,s+i),f=s;l.push(X(t,u,r,n).then(e=>(r&&r.debug(`Writing points end ${n}: ${f}/${a.length}`),e))),s+=i,e++}let i=await Promise.all(l);for(let e=0;e<i.length;e++){await v.write(i[e][0]);let t=await o.batchLEMtoU(i[e][0]);f.update(t)}l=[]}await i.endWriteSection(v)}async function X(e,t,a,i){let r,o,l,s,u,f;let d=h[e],c=2*d.F.n8,g=3*d.F.n8,w=2*d.F.n8;if("G1"==e)r="g1m_timesScalarAffine",o="g1m_multiexpAffine",l="g1m_batchToAffine",s="g1m_zero";else if("G2"==e)r="g2m_timesScalarAffine",o="g2m_multiexpAffine",l="g2m_batchToAffine",s="g2m_zero";else throw Error("Invalid group");let m=0;for(let e=0;e<t.length;e++)m+=t[e]?t[e].length:0;m>32768?(u=new n.BigBuffer(m*c),f=new n.BigBuffer(m*h.Fr.n8)):(u=new Uint8Array(m*c),f=new Uint8Array(m*h.Fr.n8));let b=0,p=0,v=[Z,V,W,j],y=new Uint8Array(h.Fr.n8);h.Fr.toRprLE(y,0,h.Fr.e(1));let S=0;for(let e=0;e<t.length;e++)if(t[e])for(let n=0;n<t[e].length;n++)a&&n&&n%1e4==0&&a.debug(`Configuring big array ${i}: ${n}/${t[e].length}`),u.set(v[t[e][n][0]].slice(t[e][n][1],t[e][n][1]+c),S*c),t[e][n][2]>=0?f.set(O.slice(t[e][n][2],t[e][n][2]+h.Fr.n8),S*h.Fr.n8):f.set(y,S*h.Fr.n8),S++;if(t.length>1){let e=[];e.push({cmd:"ALLOCSET",var:0,buff:u}),e.push({cmd:"ALLOCSET",var:1,buff:f}),e.push({cmd:"ALLOC",var:2,len:t.length*g}),b=0,p=0;let a=0;for(let i=0;i<t.length;i++){if(!t[i]){e.push({cmd:"CALL",fnName:s,params:[{var:2,offset:a}]}),a+=g;continue}1==t[i].length?e.push({cmd:"CALL",fnName:r,params:[{var:0,offset:b},{var:1,offset:p},{val:h.Fr.n8},{var:2,offset:a}]}):e.push({cmd:"CALL",fnName:o,params:[{var:0,offset:b},{var:1,offset:p},{val:h.Fr.n8},{val:t[i].length},{var:2,offset:a}]}),b+=c*t[i].length,p+=h.Fr.n8*t[i].length,a+=g}e.push({cmd:"CALL",fnName:l,params:[{var:2},{val:t.length},{var:2}]}),e.push({cmd:"GET",out:0,var:2,len:t.length*w});let i=await h.tm.queueAction(e);return i}{let e=await d.multiExpAffine(u,f,a,i);return[d.toAffine(e)]}}async function Y(){et(E-1);for(let e=0;e<E-1;e+=16384){r&&r.debug(`HashingHPoints: ${e}/${E}`);let t=Math.min(E-1,16384);await J(e,t)}}async function J(e,t){let a=await d.read(t*y,c[2][0].p+(e+E)*y),i=await d.read(t*y,c[2][0].p+e*y),n=h.tm.concurrency,r=Math.floor(t/n),o=[];for(let e=0;e<n;e++){let l;if(0==(l=e<n-1?r:t-e*r))continue;let s=a.slice(e*r*y,(e*r+l)*y),u=i.slice(e*r*y,(e*r+l)*y);o.push(ee(s,u))}let l=await Promise.all(o);for(let e=0;e<l.length;e++)f.update(l[e][0])}async function ee(e,t){let a=e.byteLength/y,i=3*h.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:e}),n.push({cmd:"ALLOCSET",var:1,buff:t}),n.push({cmd:"ALLOC",var:2,len:a*i});for(let e=0;e<a;e++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:e*y},{var:1,offset:e*y},{var:2,offset:e*i}]});n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:a*y});let r=await h.tm.queueAction(n);return r}function et(e){let t=new Uint8Array(4),a=new DataView(t.buffer,t.byteOffset,t.byteLength);a.setUint32(0,e,!1),f.update(t)}}async function e_(e,t,a,i){await w.default.ready();let{fd:r,sections:o}=await g.readBinFile(a,"zkey",2),l=await $(r,o,!1);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let s=await E(l.q),u=2*s.G1.F.n8,f=await j(r,s,o),d=w.default(64);d.update(f.csHash);let c=s.G1.g;for(let e=0;e<f.contributions.length;e++){let t=f.contributions[e],a=function(e){let t=e.getPartialHash(),a=w.default(64);return a.setPartialHash(t),a}(d);if(H(a,s,t.delta.g1_s),H(a,s,t.delta.g1_sx),!A(a.digest(),t.transcript))return console.log(`INVALID(${e}): Inconsistent transcript `),!1;let i=ec(s,t.transcript);if(!0!==await _(s,t.delta.g1_s,t.delta.g1_sx,i,t.delta.g2_spx))return console.log(`INVALID(${e}): public key G1 and G2 do not have the same ration `),!1;if(!0!==await _(s,c,t.deltaAfter,i,t.delta.g2_spx))return console.log(`INVALID(${e}): deltaAfter does not fillow the public key `),!1;if(1==t.type){let a=await G(t.beaconHash,t.numIterationsExp),i=s.Fr.fromRng(a),n=s.G1.toAffine(s.G1.fromRng(a)),r=s.G1.toAffine(s.G1.timesFr(n,i));if(!0!==s.G1.eq(n,t.delta.g1_s))return console.log(`INVALID(${e}): Key of the beacon does not match. g1_s `),!1;if(!0!==s.G1.eq(r,t.delta.g1_sx))return console.log(`INVALID(${e}): Key of the beacon does not match. g1_sx `),!1}K(d,s,t);let n=w.default(64);K(n,s,t),t.contributionHash=n.digest(),c=t.deltaAfter}let{fd:h,sections:m}=await g.readBinFile(e,"zkey",2),b=await $(h,m,!1);if("groth16"!=b.protocol)throw Error("zkeyinit file is not groth16");if(!n.Scalar.eq(b.q,l.q)||!n.Scalar.eq(b.r,l.r)||b.n8q!=l.n8q||b.n8r!=l.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(b.nVars!=l.nVars||b.nPublic!=l.nPublic||b.domainSize!=l.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!s.G1.eq(l.vk_alpha_1,b.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!s.G1.eq(l.vk_beta_1,b.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!s.G2.eq(l.vk_beta_2,b.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!s.G2.eq(l.vk_gamma_2,b.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!s.G1.eq(l.vk_delta_1,c))return i&&i.error("INVALID:  Invalid delta1"),!1;if(!0!==await _(s,s.G1.g,c,s.G2.g,l.vk_delta_2))return i&&i.error("INVALID:  Invalid delta2"),!1;let p=await j(h,s,m);if(!A(f.csHash,p.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(o[8][0].size!=u*(l.nVars-l.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(o[9][0].size!=u*l.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;if(!await g.sectionIsEqual(r,o,h,m,3))return i&&i.error("INVALID:  IC section is not identical"),!1;if(!await g.sectionIsEqual(r,o,h,m,4))return i&&i.error("Coeffs section is not identical"),!1;if(!await g.sectionIsEqual(r,o,h,m,5))return i&&i.error("A section is not identical"),!1;if(!await g.sectionIsEqual(r,o,h,m,6))return i&&i.error("B1 section is not identical"),!1;if(!await g.sectionIsEqual(r,o,h,m,7))return i&&i.error("B2 section is not identical"),!1;if(!0!==await y("G1",h,m,r,o,8,l.vk_delta_2,b.vk_delta_2,"L section"))return i&&i.error("L section does not match"),!1;if(!0!==await S())return i&&i.error("H section does not match"),!1;i&&i.info(L(f.csHash,"Circuit Hash: ")),await r.close(),await h.close();for(let e=f.contributions.length-1;e>=0;e--){var v;let t=f.contributions[e];i&&i.info("-------------------------"),i&&i.info(L(t.contributionHash,`contribution #${e+1} ${t.name?t.name:""}:`)),1==t.type&&(i&&i.info(`Beacon generator: ${(v=t.beaconHash,Array.prototype.map.call(v,function(e){return("0"+(255&e).toString(16)).slice(-2)}).join(""))}`),i&&i.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function y(e,t,a,n,r,o,l,u,f){let d=s[e],c=2*d.F.n8;await g.startReadUniqueSection(t,a,o),await g.startReadUniqueSection(n,r,o);let h=d.zero,w=d.zero,m=a[o][0].size/c;for(let e=0;e<m;e+=1048576){i&&i.debug(`Same ratio check ${f}:  ${e}/${m}`);let a=Math.min(m-e,1048576),r=await t.read(a*c),o=await n.read(a*c),l=T(4*a),s=await d.multiExpAffine(r,l),u=await d.multiExpAffine(o,l);h=d.add(h,s),w=d.add(w,u)}return await g.endReadSection(t),await g.endReadSection(n),0==m||!0===await _(s,h,w,l,u)}async function S(){let e;let a=s.G1,u=s.Fr,f=2*a.F.n8,{fd:d,sections:c}=await g.readBinFile(t,"ptau",1),h=new n.BigBuffer(l.domainSize*l.n8r),w=Array(8);for(let e=0;e<8;e++)w[e]=R(T(4),0);let m=new n.ChaCha(w);for(let e=0;e<l.domainSize-1;e++){let t=u.fromRng(m);u.toRprLE(h,e*l.n8r,t)}u.toRprLE(h,(l.domainSize-1)*l.n8r,u.zero);let p=a.zero;for(let e=0;e<l.domainSize;e+=1048576){i&&i.debug(`H Verificaition(tau):  ${e}/${l.domainSize}`);let t=Math.min(l.domainSize-e,1048576),n=await d.read(f*t,c[2][0].p+l.domainSize*f+e*f),r=await d.read(f*t,c[2][0].p+e*f),o=await C(n,r),s=h.slice(e*l.n8r,(e+t)*l.n8r),u=await a.multiExpAffine(o,s);p=a.add(p,u)}if(h=await u.batchToMontgomery(h),l.power<u.s)e=u.neg(u.e(2));else{let t=2**u.s,a=u.exp(u.shift,t);e=u.sub(a,u.one)}let v=l.power<u.s?u.w[l.power+1]:u.shift;h=await u.batchApplyKey(h,e,v),h=await u.fft(h),h=await u.batchFromMontgomery(h),await g.startReadUniqueSection(r,o,9);let y=a.zero;for(let e=0;e<l.domainSize;e+=1048576){i&&i.debug(`H Verificaition(lagrange):  ${e}/${l.domainSize}`);let t=Math.min(l.domainSize-e,1048576),n=await r.read(f*t),o=h.slice(e*l.n8r,(e+t)*l.n8r),s=await a.multiExpAffine(n,o);y=a.add(y,s)}return await g.endReadSection(r),!0===await _(s,p,y,l.vk_delta_2,b.vk_delta_2)}async function C(e,t){let a=2*s.G1.F.n8,i=e.byteLength/a,n=s.tm.concurrency,r=Math.floor(i/n),o=[];for(let a=0;a<n;a++){let l;if(0==(l=a<n-1?r:i-a*r))continue;let s=e.slice(a*r*u,(a*r+l)*u),f=t.slice(a*r*u,(a*r+l)*u);o.push(F(s,f))}let l=await Promise.all(o),f=new Uint8Array(i*a),d=0;for(let e=0;e<l.length;e++)f.set(l[e][0],d),d+=l[e][0].byteLength;return f}async function F(e,t){let a=2*s.G1.F.n8,i=3*s.G1.F.n8,n=e.byteLength/a,r=[];r.push({cmd:"ALLOCSET",var:0,buff:e}),r.push({cmd:"ALLOCSET",var:1,buff:t}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let e=0;e<n;e++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:e*a},{var:1,offset:e*a},{var:2,offset:e*i}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*a});let o=await s.tm.queueAction(r);return o}}let{stringifyBigInts:eT}=n.utils;async function ez(e,t){let a;t&&t.info("EXPORT VERIFICATION KEY STARTED");let{fd:i,sections:n}=await g.readBinFile(e,"zkey",2),r=await $(i,n);if(t&&t.info("> Detected protocol: "+r.protocol),"groth16"===r.protocol)a=await eR(r,i,n);else if("plonk"===r.protocol)a=await eP(r);else if(r.protocolId&&10===r.protocolId)a=await eG(r);else throw Error("zkey file protocol unrecognized");return await i.close(),t&&t.info("EXPORT VERIFICATION KEY FINISHED"),a}async function eR(e,t,a){let i=await E(e.q),n=2*i.G1.F.n8,r=await i.pairing(e.vk_alpha_1,e.vk_beta_2),o={protocol:e.protocol,curve:i.name,nPublic:e.nPublic,vk_alpha_1:i.G1.toObject(e.vk_alpha_1),vk_beta_2:i.G2.toObject(e.vk_beta_2),vk_gamma_2:i.G2.toObject(e.vk_gamma_2),vk_delta_2:i.G2.toObject(e.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await g.startReadUniqueSection(t,a,3),o.IC=[];for(let a=0;a<=e.nPublic;a++){let e=await t.read(n),a=i.G1.toObject(e);o.IC.push(a)}return await g.endReadSection(t),o=eT(o)}async function eP(e){let t=await E(e.q);return eT({protocol:e.protocol,curve:t.name,nPublic:e.nPublic,power:e.power,k1:t.Fr.toObject(e.k1),k2:t.Fr.toObject(e.k2),Qm:t.G1.toObject(e.Qm),Ql:t.G1.toObject(e.Ql),Qr:t.G1.toObject(e.Qr),Qo:t.G1.toObject(e.Qo),Qc:t.G1.toObject(e.Qc),S1:t.G1.toObject(e.S1),S2:t.G1.toObject(e.S2),S3:t.G1.toObject(e.S3),X_2:t.G2.toObject(e.X_2),w:t.Fr.toObject(t.Fr.w[e.power])})}async function eG(e,t){let a=await E(e.q);return eT({protocol:e.protocol,curve:a.name,nPublic:e.nPublic,power:e.power,k1:a.Fr.toObject(e.k1),k2:a.Fr.toObject(e.k2),w:a.Fr.toObject(a.Fr.w[e.power]),w3:a.Fr.toObject(e.w3),w4:a.Fr.toObject(e.w4),w8:a.Fr.toObject(e.w8),wr:a.Fr.toObject(e.wr),X_2:a.G2.toObject(e.X_2),C0:a.G1.toObject(e.C0)})}let{unstringifyBigInts:eU,stringifyBigInts:eI}=n.utils;async function eO(e,t,a){a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");let i=await x(e.curve),n=u(e.w3);e.w3_2=f(i.Fr.square(n));let r=u(e.w4);e.w4_2=f(i.Fr.square(r)),e.w4_3=f(i.Fr.mul(i.Fr.square(r),r));let o=u(e.w8),l=i.Fr.one;for(let t=1;t<8;t++)l=i.Fr.mul(l,o),e["w8_"+t]=f(l);let s=t[e.protocol];return a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),p.default.render(s,e);function u(e){let t=eU(e);return i.Fr.fromObject(t)}function f(e){let t=i.Fr.toObject(e);return eI(t)}}class ek{constructor(e,t){this.curve=e,this.logger=t,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(e,t){e in this.polynomials&&this.logger.warn(`proof: polynomial.${e} already exist in proof`),this.polynomials[e]=t}getPolynomial(e){return e in this.polynomials||this.logger.warn(`proof: polynomial ${e} does not exist in proof`),this.polynomials[e]}addEvaluation(e,t){e in this.evaluations&&this.logger.warn(`proof: evaluations.${e} already exist in proof`),this.evaluations[e]=t}getEvaluation(e){return e in this.evaluations||this.logger.warn(`proof: evaluation ${e} does not exist in proof`),this.evaluations[e]}toObjectProof(e=!0){let t=e?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{let i=this.curve.G1.toObject(this.polynomials[a]);e?t.polynomials[a]=i:t[a]=i}),Object.keys(this.evaluations).forEach(a=>{let i=this.curve.Fr.toObject(this.evaluations[a]);e?t.evaluations[a]=i:t[a]=i}),t}fromObjectProof(e){this.resetProof(),Object.keys(e.polynomials).forEach(t=>{this.polynomials[t]=this.curve.G1.fromObject(e.polynomials[t])}),Object.keys(e.evaluations).forEach(t=>{this.evaluations[t]=this.curve.Fr.fromObject(e.evaluations[t])})}}let{keccak256:eq}=v.default;class e${constructor(e){this.G1=e.G1,this.Fr=e.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(e){this.data.push({type:0,data:e})}addScalar(e){this.data.push({type:1,data:e})}getChallenge(){if(0===this.data.length)throw Error("Keccak256Transcript: No data to generate a transcript");let e=0,t=0;this.data.forEach(a=>0===a.type?e++:t++);let a=new Uint8Array(t*this.Fr.n8+e*this.G1.F.n8*2),i=0;for(let e=0;e<this.data.length;e++)0===this.data[e].type?(this.G1.toRprUncompressed(a,i,this.data[e].data),i+=2*this.G1.F.n8):(this.Fr.toRprBE(a,i,this.data[e].data),i+=this.Fr.n8);let r=n.Scalar.fromRprBE(new Uint8Array(eq.arrayBuffer(a)));return this.Fr.e(r)}}class eQ{static getZ1(e){return[e.zero,e.add(e.e(-1),e.w[2]),e.e(-2),e.sub(e.e(-1),e.w[2])]}static getZ2(e){return[e.zero,e.add(e.zero,e.mul(e.e(-2),e.w[2])),e.e(4),e.sub(e.zero,e.mul(e.e(-2),e.w[2]))]}static getZ3(e){return[e.zero,e.add(e.e(2),e.mul(e.e(2),e.w[2])),e.e(-8),e.sub(e.e(2),e.mul(e.e(2),e.w[2]))]}static mul2(e,t,a,i,n,r){let o;let l=this.getZ1(r),s=r.mul(e,t),u=r.mul(e,i),f=r.mul(a,t),d=r.mul(a,i);return o=r.add(u,f),n&&(o=r.add(o,r.mul(l[n],d))),[s,o]}static mul3(e,t,a,i,n,r,o,l){let s,u;let f=this.getZ1(l),d=this.getZ2(l),c=l.mul(e,t),h=l.mul(e,n),g=l.mul(i,t),w=l.mul(i,n);s=l.mul(c,a);let m=l.mul(g,a);m=l.add(m,l.mul(h,a)),m=l.add(m,l.mul(c,r));let b=l.mul(w,a);if(b=l.add(b,l.mul(h,r)),b=l.add(b,l.mul(g,r)),u=m,o){let e=l.mul(w,r);u=l.add(u,l.mul(f[o],b)),u=l.add(u,l.mul(d[o],e))}return[s,u]}static mul4(e,t,a,i,n,r,o,l,s,u){let f,d;let c=this.getZ1(u),h=this.getZ2(u),g=this.getZ3(u),w=u.mul(e,t),m=u.mul(e,r),b=u.mul(n,t),p=u.mul(n,r),v=u.mul(a,i),y=u.mul(a,l),S=u.mul(o,i),C=u.mul(o,l);f=u.mul(w,v);let F=u.mul(b,v);F=u.add(F,u.mul(m,v)),F=u.add(F,u.mul(w,S)),F=u.add(F,u.mul(w,y));let E=u.mul(p,v);E=u.add(E,u.mul(b,S)),E=u.add(E,u.mul(b,y)),E=u.add(E,u.mul(m,S)),E=u.add(E,u.mul(m,y)),E=u.add(E,u.mul(w,C));let x=u.mul(m,C);x=u.add(x,u.mul(b,C)),x=u.add(x,u.mul(p,y)),x=u.add(x,u.mul(p,S));let B=u.mul(p,C);return d=F,s&&(d=u.add(d,u.mul(c[s],E)),d=u.add(d,u.mul(h[s],x)),d=u.add(d,u.mul(g[s],B))),[f,d]}}class eM{constructor(e,t,a){this.coef=e,this.curve=t,this.Fr=t.Fr,this.G1=t.G1,this.logger=a}static async fromEvaluations(e,t,a){let i=await t.Fr.ifft(e);return new eM(i,t,a)}static fromCoefficientsArray(e,t,a){let i=t.Fr,r=e.length>32768?new n.BigBuffer(e.length*i.n8):new Uint8Array(e.length*i.n8);for(let t=0;t<e.length;t++)r.set(e[t],t*i.n8);return new eM(r,t,a)}static fromPolynomial(e,t,a){let i=e.length(),r=t.Fr,o=i>32768?new n.BigBuffer(i*r.n8):new Uint8Array(i*r.n8);return o.set(e.coef.slice(),0),new eM(o,t,a)}isEqual(e){let t=this.degree();if(t!==e.degree())return!1;for(let a=0;a<t+1;a++)if(!this.Fr.eq(this.getCoef(a),e.getCoef(a)))return!1;return!0}blindCoefficients(e){e=e||[];let t=this.length()+e.length>32768?new n.BigBuffer((this.length()+e.length)*this.Fr.n8):new Uint8Array((this.length()+e.length)*this.Fr.n8);t.set(this.coef,0);for(let a=0;a<e.length;a++)t.set(this.Fr.add(t.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),e[a]),(this.length()+a)*this.Fr.n8),t.set(this.Fr.sub(t.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),e[a]),a*this.Fr.n8);this.coef=t}getCoef(e){let t=e*this.Fr.n8;return t+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(t,t+this.Fr.n8)}setCoef(e,t){if(e>this.length()-1)throw Error("Coef index is not available");this.coef.set(t,e*this.Fr.n8)}static async to4T(e,t,a,i){a=a||[];let r=await i.ifft(e),o=4*t>32768?new n.BigBuffer(4*t*i.n8):new Uint8Array(4*t*i.n8);o.set(r,0);let l=await i.fft(o);if(0===a.length)return[r,l];let s=t+a.length>32768?new n.BigBuffer((t+a.length)*i.n8):new Uint8Array((t+a.length)*i.n8);s.set(r,0);for(let e=0;e<a.length;e++)s.set(i.add(s.slice((t+e)*i.n8,(t+e+1)*i.n8),a[e]),(t+e)*i.n8),s.set(i.sub(s.slice(e*i.n8,(e+1)*i.n8),a[e]),e*i.n8);return[s,l]}length(){let e=this.coef.byteLength/this.Fr.n8;if(e!==Math.floor(this.coef.byteLength/this.Fr.n8))throw Error("Polynomial coefficients buffer has incorrect size");return 0===e&&this.logger&&this.logger.warn("Polynomial has length zero"),e}degree(){for(let e=this.length()-1;e>0;e--){let t=e*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(t,t+this.Fr.n8)))return e}return 0}evaluate(e){let t=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8,n=this.coef.slice(i-this.Fr.n8,i);t=this.Fr.add(n,this.Fr.mul(t,e))}return t}fastEvaluate(e){let t=this.Fr,a=this.degree()+1,i=parseInt(a/3),n=a-3*i,r=[],o=[];o[0]=t.one;for(let a=0;a<3;a++){r[a]=t.zero;let l=2===a?i+n:i;for(let n=l;n>0;n--)r[a]=t.add(this.getCoef(a*i+n-1),t.mul(r[a],e)),0===a&&(o[0]=t.mul(o[0],e))}for(let e=1;e<3;e++)r[0]=t.add(r[0],t.mul(o[e-1],r[e])),o[e]=t.mul(o[e-1],o[0]);return r[0]}add(e,t){let a=!1;e.length()>this.length()&&(a=!0);let i=this.length(),n=e.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?e.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==t&&(s=this.Fr.mul(s,t)),a?e.coef.set(this.Fr.add(l,s),o):this.coef.set(this.Fr.add(l,s),o)}a&&(delete this.coef,this.coef=e.coef)}sub(e,t){let a=!1;e.length()>this.length()&&(a=!0);let i=this.length(),n=e.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?e.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==t&&(s=this.Fr.mul(s,t)),a?e.coef.set(this.Fr.sub(l,s),o):this.coef.set(this.Fr.sub(l,s),o)}a&&(delete this.coef,this.coef=e.coef)}mulScalar(e){for(let t=0;t<this.length();t++){let a=t*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),e),a)}}addScalar(e){let t=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(t,e),0)}subScalar(e){let t=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(t,e),0)}byXSubValue(e){let t=this.Fr,a=!t.eq(t.zero,this.getCoef(this.length()-1)),i=a?this.length()+1:this.length(),r=i>32768?new n.BigBuffer(i*t.n8):new Uint8Array(i*t.n8),o=new eM(r,this.curve,this.logger);o.coef.set(this.coef.slice(0,(i-1)*t.n8),32),this.mulScalar(t.neg(e)),o.add(this),this.coef=o.coef}byXNSubValue(e,t){let a=this.Fr,i=!(this.length()-e-1>=this.degree()),r=i?this.length()+e:this.length(),o=r>32768?new n.BigBuffer(r*a.n8):new Uint8Array(r*a.n8),l=new eM(o,this.curve,this.logger);l.coef.set(this.coef.slice(0,(this.degree()+1)*32),32*e),this.mulScalar(t),l.add(this),this.coef=l.coef}divBy(e){let t=this.Fr,a=this.degree(),i=e.degree(),r=new eM(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*t.n8):new Uint8Array(this.length()*t.n8);for(let n=a-i;n>=0;n--){this.setCoef(n,t.div(r.getCoef(n+i),e.getCoef(i)));for(let a=0;a<=i;a++)r.setCoef(n+a,t.sub(r.getCoef(n+a),t.mul(this.getCoef(n),e.getCoef(a))))}return r}divByMonic(e,t){let a=this.Fr,i=this.degree(),r=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8),o=new eM(r,this.curve,this.logger),l=[];for(let t=0;t<e;t++)o.setCoef(i-t-e,this.getCoef(i-t)),l[t]=this.getCoef(i-t);for(let n=0;n<e;n++)for(let r=i-2*e-n;r>=0&&!(r<0);r-=e){let i=n;l[i]=a.add(this.getCoef(r+e),a.mul(l[i],t)),o.setCoef(r,l[i])}this.coef=o.coef}divByVanishing(e,t){if(this.degree()<e)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new eM(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let n=this.length()-1;n>=e;n--){let r=i.getCoef(n);a.eq(a.zero,r)||(i.setCoef(n,a.zero),i.setCoef(n-e,a.add(i.getCoef(n-e),a.mul(t,r))),this.setCoef(n-e,a.add(this.getCoef(n-e),r)))}return i}divByVanishing2(e,t){if(this.degree()<e)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new eM(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let r=this.length()-e,o=Math.floor(r/3),l=r-2*o;console.log(r),console.log(o+"  "+l);for(let n=0;n<3;n++){console.log("> Thread "+n);for(let r=0===n?l:o;r>0;r--){let s=r-1;0!==n&&(s+=(n-1)*o+l);let u=s+e,f=i.getCoef(u);a.eq(a.zero,f)||(i.setCoef(u,a.zero),i.setCoef(s,a.add(i.getCoef(s),a.mul(t,f))),this.setCoef(s,a.add(this.getCoef(s),f)),console.log(s+" <-- "+u))}}return this.print(),i}fastDivByVanishing(e){let t=this.Fr;for(let a=0;a<e.length;a++){let i=e[a][0],r=e[a][1];if(this.degree()<i)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let o=this.length()-i,l=Math.floor(o/5/i),s=l*i,u=o-5*s,f=new eM(this.length()>32768?new n.BigBuffer(this.length()*t.n8):new Uint8Array(this.length()*t.n8),this.curve,this.logger),d=this.coef;this.coef=f.coef,f.coef=d;for(let e=0;e<5;e++){let a=(e+1)*s+u;for(let e=0;e<i;e++)this.setCoef(a+e-i,f.getCoef(a+e));for(let e=0;e<s-i;e++){let n=a-e-1,o=t.add(f.getCoef(n),t.mul(r,this.getCoef(n)));this.setCoef(n-i,o)}}let c=u;for(let e=0;e<i&&c;e++)this.setCoef(u-e-1,f.getCoef(u+i-e-1)),c--;for(let e=0;e<c;e++){let a=u-e-1,n=t.add(f.getCoef(a),t.mul(r,this.getCoef(a)));this.setCoef(a-i,n)}let h=[],g=t.one;for(let e=0;e<l;e++)g=t.mul(g,r);let w=t.one;for(let e=5;e>0;e--){let a=e-1,n=a*s+u;h[a]=[];for(let r=0;r<i;r++)h[a][r]=this.getCoef(n+r),5!==e&&(h[a][r]=t.add(h[a][r],t.mul(g,h[a+1][r])));w=t.mul(w,g)}for(let e=0;e<5;e++){let a=e*s+u,n=r,o=i-1,l=0===e?u:s;for(let s=0;s<l;s++){let l=a-s-1,u=t.add(this.getCoef(l),t.mul(n,h[e][o]));this.setCoef(l,u),0===o?(o=i-1,n=t.mul(n,r)):o--}}}}divByXSubValue(e){let t=this.length()>32768?new n.BigBuffer(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);t.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),t.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;t.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(e,t.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(e),t.slice(0,this.Fr.n8))))throw Error("Polynomial does not divide");this.coef=t}divZh(e,t=4){for(let t=0;t<e;t++){let e=t*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(e,e+this.Fr.n8)),e)}let a=this.coef.byteLength/this.Fr.n8;for(let i=e;i<a;i++){let a=i*this.Fr.n8,n=this.Fr.sub(this.coef.slice((i-e)*this.Fr.n8,(i-e)*this.Fr.n8+this.Fr.n8),this.coef.slice(a,a+this.Fr.n8));if(this.coef.set(n,a),i>e*(t-1)-t&&!this.Fr.isZero(n))throw Error("Polynomial is not divisible")}return this}divByZerofier(e,t){let a=this.Fr,i=a.inv(t),n=a.neg(i),r=a.eq(a.one,n),o=a.eq(a.negone,n);if(!r)for(let t=0;t<e;t++){let e;let i=t*this.Fr.n8;e=o?a.neg(this.coef.slice(i,i+this.Fr.n8)):a.mul(n,this.coef.slice(i,i+this.Fr.n8)),this.coef.set(e,i)}r=a.eq(a.one,i),o=a.eq(a.negone,i);for(let t=e;t<this.length();t++){let n=t*this.Fr.n8,l=(t-e)*this.Fr.n8,s=this.Fr.sub(this.coef.slice(l,l+this.Fr.n8),this.coef.slice(n,n+this.Fr.n8));if(r||(s=o?a.neg(s):a.mul(i,s)),this.coef.set(s,n),t>this.length()-e-1&&!this.Fr.isZero(s))throw Error("Polynomial is not divisible")}return this}byX(){let e=this.length()+1>32768?new n.BigBuffer(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);e.set(this.Fr.zero,0),e.set(this.coef,this.Fr.n8),this.coef=e}static;async expX(e,t,a=!1){let i=e.Fr;if(t<1)throw Error("Compute a new polynomial to a zero or negative number is not allowed");if(1===t)return await eM.fromEvaluations(e.coef,curve,e.logger);let r=a?e.degree():e.length()-1,o=r*t+1>32768?new n.BigBuffer((r*t+1)*i.n8):new Uint8Array((r*t+1)*i.n8);o.set(e.getCoef(0),0);for(let a=1;a<=r;a++){let n=a*i.n8,r=e.getCoef(a);o.set(r,n*t)}return new eM(o,e.curve,e.logger)}split(e,t,a){if(e<1)throw Error(`Polynomials can't be split in ${e} parts`);if(1===e)return[this];if(0!==a.length&&a.length<e-1)throw Error(`Blinding factors length must be ${e-1}`);let i=(t+1)*this.Fr.n8,r=[],o=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(o<e)for(let t=o;t<e;t++)r[t]=new eM(new Uint8Array(this.Fr.n8),this.curve,this.logger);e=Math.min(e,o);for(let t=0;t<e;t++){let o=e-1===t,l=o?this.coef.byteLength-(e-1)*i:i+this.Fr.n8,s=l/this.Fr.n8>32768?new n.BigBuffer(l):new Uint8Array(l);r[t]=new eM(s,this.curve,this.logger);let u=t*i,f=o?this.coef.byteLength:(t+1)*i;if(r[t].coef.set(this.coef.slice(u,f),0),o||r[t].coef.set(a[t],i),0!==t){let e=this.Fr.sub(r[t].coef.slice(0,this.Fr.n8),a[t-1]);r[t].coef.set(e,0)}o&&r[t].truncate()}return r}truncate(){let e=this.degree();if(e+1<this.coef.byteLength/this.Fr.n8){let t=e+1>32768?new n.BigBuffer((e+1)*this.Fr.n8):new Uint8Array((e+1)*this.Fr.n8);t.set(this.coef.slice(0,(e+1)*this.Fr.n8),0),this.coef=t}}static lagrangePolynomialInterpolation(e,t,a){let i=a.Fr,r=o(0);for(let t=1;t<e.length;t++)r.add(o(t));return r;function o(r){let o;for(let t=0;t<e.length;t++)if(t!==r){if(void 0===o){let r=e.length>32768?new n.BigBuffer(e.length*i.n8):new Uint8Array(e.length*i.n8);(o=new eM(r,a)).setCoef(0,i.neg(e[t])),o.setCoef(1,i.one)}else o.byXSubValue(e[t])}let l=o.evaluate(e[r]);l=i.inv(l);let s=i.mul(t[r],l);return o.mulScalar(s),o}}static zerofierPolynomial(e,t){let a=t.Fr,i=e.length+1>32768?new n.BigBuffer((e.length+1)*a.n8):new Uint8Array((e.length+1)*a.n8),r=new eM(i,t);r.setCoef(0,a.neg(e[0])),r.setCoef(1,a.one);for(let t=1;t<e.length;t++)r.byXSubValue(e[t]);return r}print(){let e=this.Fr,t="";for(let a=this.degree();a>=0;a--){let i=this.getCoef(a);!e.eq(e.zero,i)&&(e.isNegative(i)?t+=" - ":a!==this.degree()&&(t+=" + "),t+=e.toString(i),a>0&&(t+=a>1?"x^"+a:"x"))}console.log(t)}async multiExponentiation(e,t){let a=this.coef.byteLength/this.Fr.n8,i=e.slice(0,a*this.G1.F.n8*2),n=await this.Fr.batchFromMontgomery(this.coef),r=await this.G1.multiExpAffine(i,n,this.logger,t);return this.G1.toAffine(r)}}class eZ{constructor(e,t,a){this.eval=e,this.curve=t,this.Fr=t.Fr,this.logger=a}static async fromPolynomial(e,t,a,i){let r=new n.BigBuffer(e.length()*t*a.Fr.n8);r.set(e.coef,0);let o=await a.Fr.fft(r);return new eZ(o,a,i)}getEvaluation(e){let t=e*this.Fr.n8;if(t+this.Fr.n8>this.eval.byteLength)throw Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(t,t+this.Fr.n8)}length(){let e=this.eval.byteLength/this.Fr.n8;if(e!==Math.floor(this.eval.byteLength/this.Fr.n8))throw Error("Polynomial evaluations buffer has incorrect size");return 0===e&&this.logger.warn("Polynomial has length zero"),e}}let{stringifyBigInts:eV}=n.utils;async function eW(e,t,a){let{fd:i,sections:r}=await g.readBinFile(t,"wtns",2,33554432,8388608);a&&a.debug("> Reading witness file");let o=await Y(i,r);a&&a.debug("> Reading zkey file");let{fd:l,sections:s}=await g.readBinFile(e,"zkey",2,33554432,8388608),u=await $(l,s);if("plonk"!=u.protocol)throw Error("zkey file is not plonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let f=u.curve,d=f.Fr,c=f.Fr.n8,h=u.domainSize*c;a&&(a.debug("----------------------------"),a.debug("  PLONK PROVE SETTINGS"),a.debug(`  Curve:         ${f.name}`),a.debug(`  Circuit power: ${u.power}`),a.debug(`  Domain size:   ${u.domainSize}`),a.debug(`  Vars:          ${u.nVars}`),a.debug(`  Public vars:   ${u.nPublic}`),a.debug(`  Constraints:   ${u.nConstraints}`),a.debug(`  Additions:     ${u.nAdditions}`),a.debug("----------------------------")),a&&a.debug("> Reading witness file data");let w=await g.readSection(i,r,2);w.set(d.zero,0);let m=new n.BigBuffer(c*u.nAdditions),b={},p={},v={},y={},S=new ek(f,a),C=new e$(f);a&&a.debug("> Reading Section 3. Additions"),await B(),a&&a.debug("> Reading Section 12. Sigma1, Sigma2 & Sigma 3"),a&&a.debug("\xb7\xb7\xb7 Reading Sigma polynomials "),p.Sigma1=new eM(new n.BigBuffer(h),f,a),p.Sigma2=new eM(new n.BigBuffer(h),f,a),p.Sigma3=new eM(new n.BigBuffer(h),f,a),await l.readToBuffer(p.Sigma1.coef,0,h,s[12][0].p),await l.readToBuffer(p.Sigma2.coef,0,h,s[12][0].p+5*h),await l.readToBuffer(p.Sigma3.coef,0,h,s[12][0].p+10*h),a&&a.debug("\xb7\xb7\xb7 Reading Sigma evaluations"),v.Sigma1=new eZ(new n.BigBuffer(4*h),f,a),v.Sigma2=new eZ(new n.BigBuffer(4*h),f,a),v.Sigma3=new eZ(new n.BigBuffer(4*h),f,a),await l.readToBuffer(v.Sigma1.eval,0,4*h,s[12][0].p+h),await l.readToBuffer(v.Sigma2.eval,0,4*h,s[12][0].p+6*h),await l.readToBuffer(v.Sigma3.eval,0,4*h,s[12][0].p+11*h),a&&a.debug("> Reading Section 14. Powers of Tau");let F=await g.readSection(l,s,14),E=[];for(let e=1;e<=u.nPublic;e++){let t=w.slice(e*d.n8,e*d.n8+d.n8);E.push(n.Scalar.fromRprLE(t))}a&&a.debug(""),a&&a.debug("> ROUND 1"),await _(),a&&a.debug("> ROUND 2"),await z(),a&&a.debug("> ROUND 3"),await P(),a&&a.debug("> ROUND 4"),await U(),a&&a.debug("> ROUND 5"),await I(),await l.close(),await i.close();let x=S.toObjectProof(!1);return x.protocol="plonk",x.curve=f.name,a&&a.debug("PLONK PROVER FINISHED"),{proof:eV(x),publicSignals:eV(E)};async function B(){a&&a.debug("\xb7\xb7\xb7 Computing additions");let e=await g.readSection(l,s,3),t=8+2*c;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.debug(`    addition ${i}/${u.nAdditions}`);let n=i*t,r=L(e,n);n+=4;let o=L(e,n);n+=4;let l=e.slice(n,n+c);n+=c;let s=e.slice(n,n+c),f=A(r),h=A(o),g=d.add(d.mul(l,f),d.mul(s,h));m.set(g,c*i)}}function L(e,t){let a=e.slice(t,t+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function A(e){return e<u.nVars-u.nAdditions?w.slice(e*c,e*c+c):e<u.nVars?m.slice((e-(u.nVars-u.nAdditions))*c,(e-(u.nVars-u.nAdditions))*c+c):f.Fr.zero}async function _(){y.b=[];for(let e=1;e<=11;e++)y.b[e]=f.Fr.random();a&&a.debug("> Computing A, B, C wire polynomials"),await T(),a&&a.debug("> Computing A, B, C MSM");let e=await p.A.multiExponentiation(F,"A"),t=await p.B.multiExponentiation(F,"B"),i=await p.C.multiExponentiation(F,"C");return S.addPolynomial("A",e),S.addPolynomial("B",t),S.addPolynomial("C",i),0}async function T(){a&&a.debug("\xb7\xb7\xb7 Reading data from zkey file"),b.A=new n.BigBuffer(h),b.B=new n.BigBuffer(h),b.C=new n.BigBuffer(h);let e=await g.readSection(l,s,4),t=await g.readSection(l,s,5),i=await g.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*c,r=4*a,o=L(e,r);b.A.set(A(o),n);let l=L(t,r);b.B.set(A(l),n);let s=L(i,r);b.C.set(A(s),n)}if(b.A=await d.batchToMontgomery(b.A),b.B=await d.batchToMontgomery(b.B),b.C=await d.batchToMontgomery(b.C),a&&a.debug("\xb7\xb7\xb7 Computing A ifft"),p.A=await eM.fromEvaluations(b.A,f,a),a&&a.debug("\xb7\xb7\xb7 Computing B ifft"),p.B=await eM.fromEvaluations(b.B,f,a),a&&a.debug("\xb7\xb7\xb7 Computing C ifft"),p.C=await eM.fromEvaluations(b.C,f,a),a&&a.debug("\xb7\xb7\xb7 Computing A fft"),v.A=await eZ.fromPolynomial(p.A,4,f,a),a&&a.debug("\xb7\xb7\xb7 Computing B fft"),v.B=await eZ.fromPolynomial(p.B,4,f,a),a&&a.debug("\xb7\xb7\xb7 Computing C fft"),v.C=await eZ.fromPolynomial(p.C,4,f,a),p.A.blindCoefficients([y.b[2],y.b[1]]),p.B.blindCoefficients([y.b[4],y.b[3]]),p.C.blindCoefficients([y.b[6],y.b[5]]),p.A.degree()>=u.domainSize+2)throw Error("A Polynomial is not well calculated");if(p.B.degree()>=u.domainSize+2)throw Error("B Polynomial is not well calculated");if(p.C.degree()>=u.domainSize+2)throw Error("C Polynomial is not well calculated")}async function z(){a&&a.debug("> Computing challenges beta and gamma"),C.reset(),C.addPolCommitment(u.Qm),C.addPolCommitment(u.Ql),C.addPolCommitment(u.Qr),C.addPolCommitment(u.Qo),C.addPolCommitment(u.Qc),C.addPolCommitment(u.S1),C.addPolCommitment(u.S2),C.addPolCommitment(u.S3);for(let e=0;e<u.nPublic;e++)C.addScalar(b.A.slice(e*c,e*c+c));C.addPolCommitment(S.getPolynomial("A")),C.addPolCommitment(S.getPolynomial("B")),C.addPolCommitment(S.getPolynomial("C")),y.beta=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.beta: "+d.toString(y.beta,16)),C.reset(),C.addScalar(y.beta),y.gamma=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.gamma: "+d.toString(y.gamma,16)),a&&a.debug("> Computing Z polynomial"),await R(),a&&a.debug("> Computing Z MSM");let e=await p.Z.multiExponentiation(F,"Z");S.addPolynomial("Z",e)}async function R(){a&&a.debug("\xb7\xb7\xb7 Computing Z evaluations");let e=new n.BigBuffer(h),t=new n.BigBuffer(h);e.set(d.one,0),t.set(d.one,0);let i=d.one;for(let a=0;a<u.domainSize;a++){let n=a*c,r=b.A.slice(n,n+c),o=b.B.slice(n,n+c),l=b.C.slice(n,n+c),s=d.mul(y.beta,i),f=d.add(r,s);f=d.add(f,y.gamma);let h=d.add(o,d.mul(u.k1,s));h=d.add(h,y.gamma);let g=d.add(l,d.mul(u.k2,s));g=d.add(g,y.gamma);let w=d.mul(f,d.mul(h,g)),m=d.add(r,d.mul(v.Sigma1.getEvaluation(4*a),y.beta));m=d.add(m,y.gamma);let p=d.add(o,d.mul(v.Sigma2.getEvaluation(4*a),y.beta));p=d.add(p,y.gamma);let S=d.add(l,d.mul(v.Sigma3.getEvaluation(4*a),y.beta));S=d.add(S,y.gamma);let C=d.mul(m,d.mul(p,S));w=d.mul(e.slice(n,n+c),w),e.set(w,(a+1)%u.domainSize*c),C=d.mul(t.slice(n,n+c),C),t.set(C,(a+1)%u.domainSize*c),i=d.mul(i,d.w[u.power])}t=await d.batchInverse(t);for(let a=0;a<u.domainSize;a++){let i=a*c,n=d.mul(e.slice(i,i+c),t.slice(i,i+c));e.set(n,i)}if(b.Z=e,!d.eq(e.slice(0,c),d.one))throw Error("Copy constraints does not match");if(a&&a.debug("\xb7\xb7\xb7 Computing Z ifft"),p.Z=await eM.fromEvaluations(b.Z,f,a),a&&a.debug("\xb7\xb7\xb7 Computing Z fft"),v.Z=await eZ.fromPolynomial(p.Z,4,f,a),p.Z.blindCoefficients([y.b[9],y.b[8],y.b[7]]),p.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete b.Z}async function P(){a&&a.debug("> Computing challenge alpha"),C.reset(),C.addScalar(y.beta),C.addScalar(y.gamma),C.addPolCommitment(S.getPolynomial("Z")),y.alpha=C.getChallenge(),y.alpha2=d.square(y.alpha),a&&a.debug("\xb7\xb7\xb7 challenges.alpha: "+d.toString(y.alpha,16)),a&&a.debug("> Computing T polynomial"),await G(),a&&a.debug("> Computing T MSM");let e=await p.T1.multiExponentiation(F,"T1"),t=await p.T2.multiExponentiation(F,"T2"),i=await p.T3.multiExponentiation(F,"T3");S.addPolynomial("T1",e),S.addPolynomial("T2",t),S.addPolynomial("T3",i)}async function G(){a&&a.debug(`\xb7\xb7\xb7 Reading sections 8, 9, 7, 10, 11. Q selectors`),v.QL=new eZ(new n.BigBuffer(4*h),f,a),v.QR=new eZ(new n.BigBuffer(4*h),f,a),v.QM=new eZ(new n.BigBuffer(4*h),f,a),v.QO=new eZ(new n.BigBuffer(4*h),f,a),v.QC=new eZ(new n.BigBuffer(4*h),f,a),await l.readToBuffer(v.QL.eval,0,4*h,s[8][0].p+h),await l.readToBuffer(v.QR.eval,0,4*h,s[9][0].p+h),await l.readToBuffer(v.QM.eval,0,4*h,s[7][0].p+h),await l.readToBuffer(v.QO.eval,0,4*h,s[10][0].p+h),await l.readToBuffer(v.QC.eval,0,4*h,s[11][0].p+h),v.Lagrange=new eZ(new n.BigBuffer(4*h*u.nPublic),f,a);for(let e=0;e<u.nPublic;e++)await l.readToBuffer(v.Lagrange.eval,e*h*4,4*h,s[13][0].p+5*e*h+h);b.T=new n.BigBuffer(4*h),b.Tz=new n.BigBuffer(4*h),a&&a.debug("\xb7\xb7\xb7 Computing T evaluations");let e=d.one;for(let t=0;t<4*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.debug(`      T evaluation ${t}/${4*u.domainSize}`);let i=v.A.getEvaluation(t),n=v.B.getEvaluation(t),r=v.C.getEvaluation(t),o=v.Z.getEvaluation(t),l=v.Z.getEvaluation((4*u.domainSize+4+t)%(4*u.domainSize)),s=v.QM.getEvaluation(t),f=v.QL.getEvaluation(t),h=v.QR.getEvaluation(t),g=v.QO.getEvaluation(t),w=v.QC.getEvaluation(t),m=v.Sigma1.getEvaluation(t),p=v.Sigma2.getEvaluation(t),S=v.Sigma3.getEvaluation(t),C=d.add(y.b[2],d.mul(y.b[1],e)),F=d.add(y.b[4],d.mul(y.b[3],e)),E=d.add(y.b[6],d.mul(y.b[5],e)),x=d.square(e),B=d.add(d.add(d.mul(y.b[7],x),d.mul(y.b[8],e)),y.b[9]),L=d.mul(e,d.w[u.power]),A=d.square(L),_=d.add(d.add(d.mul(y.b[7],A),d.mul(y.b[8],L)),y.b[9]),T=d.zero;for(let e=0;e<u.nPublic;e++){let a=4*e*u.domainSize+t,i=v.Lagrange.getEvaluation(a),n=b.A.slice(e*c,(e+1)*c);T=d.sub(T,d.mul(i,n))}let[z,R]=eQ.mul2(i,n,C,F,t%4,d);z=d.mul(z,s),R=d.mul(R,s),z=d.add(z,d.mul(i,f)),R=d.add(R,d.mul(C,f)),z=d.add(z,d.mul(n,h)),R=d.add(R,d.mul(F,h)),z=d.add(z,d.mul(r,g)),R=d.add(R,d.mul(E,g)),z=d.add(z,T),z=d.add(z,w);let P=d.mul(y.beta,e),G=i;G=d.add(G,P),G=d.add(G,y.gamma);let U=n;U=d.add(U,d.mul(P,u.k1)),U=d.add(U,y.gamma);let I=r;I=d.add(I,d.mul(P,u.k2)),I=d.add(I,y.gamma);let[O,k]=eQ.mul4(G,U,I,o,C,F,E,B,t%4,d);O=d.mul(O,y.alpha),k=d.mul(k,y.alpha);let q=i;q=d.add(q,d.mul(y.beta,m)),q=d.add(q,y.gamma);let $=n;$=d.add($,d.mul(y.beta,p)),$=d.add($,y.gamma);let Q=r;Q=d.add(Q,d.mul(y.beta,S)),Q=d.add(Q,y.gamma);let[M,Z]=eQ.mul4(q,$,Q,l,C,F,E,_,t%4,d);M=d.mul(M,y.alpha),Z=d.mul(Z,y.alpha);let V=d.sub(o,d.one);V=d.mul(V,v.Lagrange.getEvaluation(t)),V=d.mul(V,y.alpha2);let W=d.mul(B,v.Lagrange.getEvaluation(t));W=d.mul(W,y.alpha2);let j=d.add(d.sub(d.add(z,O),M),V),N=d.add(d.sub(d.add(R,k),Z),W);b.T.set(j,t*c),b.Tz.set(N,t*c),e=d.mul(e,d.w[u.power+2])}if(a&&a.debug("\xb7\xb7\xb7 Computing T ifft"),p.T=await eM.fromEvaluations(b.T,f,a),a&&a.debug("\xb7\xb7\xb7 Computing T / ZH"),p.T.divZh(u.domainSize,4),a&&a.debug("\xb7\xb7\xb7 Computing Tz ifft"),p.Tz=await eM.fromEvaluations(b.Tz,f,a),p.T.add(p.Tz),p.T.degree()>=3*u.domainSize+6)throw Error("T Polynomial is not well calculated");a&&a.debug("\xb7\xb7\xb7 Computing T1, T2, T3 polynomials"),p.T1=new eM(new n.BigBuffer((u.domainSize+1)*c),f,a),p.T2=new eM(new n.BigBuffer((u.domainSize+1)*c),f,a),p.T3=new eM(new n.BigBuffer((u.domainSize+6)*c),f,a),p.T1.coef.set(p.T.coef.slice(0,h),0),p.T2.coef.set(p.T.coef.slice(h,2*h),0),p.T3.coef.set(p.T.coef.slice(2*h,3*h+6*c),0),p.T1.setCoef(u.domainSize,y.b[10]);let t=d.sub(p.T2.getCoef(0),y.b[10]);p.T2.setCoef(0,t),p.T2.setCoef(u.domainSize,y.b[11]);let i=d.sub(p.T3.getCoef(0),y.b[11]);p.T3.setCoef(0,i)}async function U(){a&&a.debug("> Computing challenge xi"),C.reset(),C.addScalar(y.alpha),C.addPolCommitment(S.getPolynomial("T1")),C.addPolCommitment(S.getPolynomial("T2")),C.addPolCommitment(S.getPolynomial("T3")),y.xi=C.getChallenge(),y.xiw=d.mul(y.xi,d.w[u.power]),a&&a.debug("\xb7\xb7\xb7 challenges.xi: "+d.toString(y.xi,16)),S.addEvaluation("eval_a",p.A.evaluate(y.xi)),S.addEvaluation("eval_b",p.B.evaluate(y.xi)),S.addEvaluation("eval_c",p.C.evaluate(y.xi)),S.addEvaluation("eval_s1",p.Sigma1.evaluate(y.xi)),S.addEvaluation("eval_s2",p.Sigma2.evaluate(y.xi)),S.addEvaluation("eval_zw",p.Z.evaluate(y.xiw))}async function I(){a&&a.debug("> Computing challenge v"),C.reset(),C.addScalar(y.xi),C.addScalar(S.getEvaluation("eval_a")),C.addScalar(S.getEvaluation("eval_b")),C.addScalar(S.getEvaluation("eval_c")),C.addScalar(S.getEvaluation("eval_s1")),C.addScalar(S.getEvaluation("eval_s2")),C.addScalar(S.getEvaluation("eval_zw")),y.v=[],y.v[1]=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.v: "+d.toString(y.v[1],16));for(let e=2;e<6;e++)y.v[e]=d.mul(y.v[e-1],y.v[1]);a&&a.debug("> Computing linearisation polynomial R(X)"),await O(),a&&a.debug("> Computing opening proof polynomial Wxi(X) polynomial"),p.Wxi=new eM(new n.BigBuffer(h+6*c),f,a),p.Wxi.add(p.R),p.Wxi.add(p.A,y.v[1]),p.Wxi.add(p.B,y.v[2]),p.Wxi.add(p.C,y.v[3]),p.Wxi.add(p.Sigma1,y.v[4]),p.Wxi.add(p.Sigma2,y.v[5]),p.Wxi.subScalar(d.mul(y.v[1],S.evaluations.eval_a)),p.Wxi.subScalar(d.mul(y.v[2],S.evaluations.eval_b)),p.Wxi.subScalar(d.mul(y.v[3],S.evaluations.eval_c)),p.Wxi.subScalar(d.mul(y.v[4],S.evaluations.eval_s1)),p.Wxi.subScalar(d.mul(y.v[5],S.evaluations.eval_s2)),p.Wxi.divByZerofier(1,y.xi),a&&a.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),k(),a&&a.debug("> Computing Wxi, Wxiw MSM");let e=await p.Wxi.multiExponentiation(F,"Wxi"),t=await p.Wxiw.multiExponentiation(F,"Wxiw");S.addPolynomial("Wxi",e),S.addPolynomial("Wxiw",t)}async function O(){let e=f.Fr;p.QL=new eM(new n.BigBuffer(h),f,a),p.QR=new eM(new n.BigBuffer(h),f,a),p.QM=new eM(new n.BigBuffer(h),f,a),p.QO=new eM(new n.BigBuffer(h),f,a),p.QC=new eM(new n.BigBuffer(h),f,a),await l.readToBuffer(p.QL.coef,0,h,s[8][0].p),await l.readToBuffer(p.QR.coef,0,h,s[9][0].p),await l.readToBuffer(p.QM.coef,0,h,s[7][0].p),await l.readToBuffer(p.QO.coef,0,h,s[10][0].p),await l.readToBuffer(p.QC.coef,0,h,s[11][0].p),y.xin=y.xi;for(let t=0;t<u.power;t++)y.xin=e.square(y.xin);y.zh=e.sub(y.xin,e.one);let t=[],i=e.e(u.domainSize),r=e.one;for(let a=1;a<=Math.max(1,u.nPublic);a++)t[a]=e.div(e.mul(r,y.zh),e.mul(i,e.sub(y.xi,r))),r=e.mul(r,e.w[u.power]);let o=e.div(e.sub(y.xin,e.one),e.mul(i,e.sub(y.xi,e.one)));if(a){a.debug("Lagrange Evaluations: ");for(let i=1;i<t.length;i++)a.debug(`L${i}(xi)=`+e.toString(t[i],16))}let d=e.zero;for(let a=0;a<E.length;a++){let i=e.e(E[a]);d=e.sub(d,e.mul(i,t[a+1]))}a&&a.debug("PI: "+e.toString(d,16));let g=e.mul(S.evaluations.eval_a,S.evaluations.eval_b),w=S.evaluations.eval_a,m=e.mul(y.beta,y.xi);w=e.add(w,m),w=e.add(w,y.gamma);let b=S.evaluations.eval_b;b=e.add(b,e.mul(m,u.k1)),b=e.add(b,y.gamma);let v=S.evaluations.eval_c;v=e.add(v,e.mul(m,u.k2)),v=e.add(v,y.gamma);let C=e.mul(e.mul(e.mul(w,b),v),y.alpha),F=S.evaluations.eval_a;F=e.add(F,e.mul(y.beta,S.evaluations.eval_s1)),F=e.add(F,y.gamma);let x=S.evaluations.eval_b;x=e.add(x,e.mul(y.beta,S.evaluations.eval_s2)),x=e.add(x,y.gamma);let B=e.mul(F,x);B=e.mul(B,S.evaluations.eval_zw),B=e.mul(B,y.alpha);let L=e.mul(o,y.alpha2);p.R=new eM(new n.BigBuffer((u.domainSize+6)*c),f,a),p.R.add(p.QM,g),p.R.add(p.QL,S.evaluations.eval_a),p.R.add(p.QR,S.evaluations.eval_b),p.R.add(p.QO,S.evaluations.eval_c),p.R.add(p.QC),p.R.add(p.Z,C),p.R.sub(p.Sigma3,e.mul(B,y.beta)),p.R.add(p.Z,L);let A=eM.fromPolynomial(p.T3,f,a);A.mulScalar(e.square(y.xin)),A.add(p.T2,y.xin),A.add(p.T1),A.mulScalar(y.zh),p.R.sub(A);let _=e.sub(d,e.mul(B,e.add(S.evaluations.eval_c,y.gamma)));_=e.sub(_,L),a&&a.debug("r0: "+e.toString(_,16)),p.R.addScalar(_)}async function k(){p.Wxiw=eM.fromPolynomial(p.Z,f,a),p.Wxiw.subScalar(S.evaluations.eval_zw),p.Wxiw.divByZerofier(1,y.xiw)}}let{unstringifyBigInts:ej}=n.utils,{unstringifyBigInts:eN}=n.utils;async function eD(e,t,a,i,n,r){let o=e.G1,l=e.Fr,s=t.Wxi;s=o.add(s,o.timesFr(t.Wxiw,a.u));let u=o.timesFr(t.Wxi,a.xi),f=l.mul(l.mul(a.u,a.xi),l.w[i.power]);u=o.add(u,o.timesFr(t.Wxiw,f)),u=o.add(u,r),u=o.sub(u,n);let d=await e.pairingEq(o.neg(s),i.X_2,u,e.G2.one);return d}let{unstringifyBigInts:eH}=n.utils;function eK(e,t){return[e,0,0,t.one,t.zero,t.zero,t.zero,t.zero]}function eX(e,t,a,i,n,r,o,l){return[e,t,a,i,n,r,o,l]}function eY(e,t,a,i,n,r,o,l,s){return[e,t,a,i,n,r,o,l]}class eJ{constructor(e,t,a,i,n){this.Fr=e,this.logger=n,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(e,t,a,i){this.normalizeLinearCombination(t),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);let n=this.getLinearCombinationType(t),r=this.getLinearCombinationType(a);if(0===n||0===r)return this.processR1csAdditionConstraint(e,i);if(1===n){let n=this.joinLinearCombinations(a,i,t[0]);return this.processR1csAdditionConstraint(e,n)}if(1!==r)return this.processR1csMultiplicationConstraint(e,t,a,i);{let n=this.joinLinearCombinations(t,i,a[0]);return this.processR1csAdditionConstraint(e,n)}}getLinearCombinationType(e){let t=this.Fr.zero,a=0,i=Object.keys(e);for(let n=0;n<i.length;n++)0n==e[i[n]]?delete e[i[n]]:0==i[n]?t=this.Fr.add(t,e[i[n]]):a++;return a>0?2:this.Fr.isZero(t)?0:1}normalizeLinearCombination(e){let t=Object.keys(e);for(let a=0;a<t.length;a++)this.Fr.isZero(e[t[a]])&&delete e[t[a]];return e}joinLinearCombinations(e,t,a){let i={};for(let t in e)void 0===i[t]?i[t]=this.Fr.mul(a,e[t]):i[t]=this.Fr.add(i[t],this.Fr.mul(a,e[t]));for(let e in t)void 0===i[e]?i[e]=t[e]:i[e]=this.Fr.add(i[e],t[e]);return this.normalizeLinearCombination(i)}reduceCoefs(e,t,a,i,n){let r={k:this.Fr.zero,signals:[],coefs:[]},o=[];for(let e in i)0==e?r.k=this.Fr.add(r.k,i[e]):0n!=i[e]&&o.push([Number(e),i[e]]);for(;o.length>n;){let i=o.shift(),n=o.shift(),r=e.nVars++,l=this.fnGetAdditionConstraint(i[0],n[0],r,this.Fr.neg(i[1]),this.Fr.neg(n[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);t.push(l),a.push([i[0],n[0],i[1],n[1]]),o.push([r,this.Fr.one])}for(let e=0;e<o.length;e++)r.signals[e]=o[e][0],r.coefs[e]=o[e][1];for(;r.coefs.length<n;)r.signals.push(0),r.coefs.push(this.Fr.zero);return r}processR1csAdditionConstraint(e,t){let a=[],i=[],n=this.reduceCoefs(e,a,i,t,3),r=this.fnGetAdditionConstraint(n.signals[0],n.signals[1],n.signals[2],n.coefs[0],n.coefs[1],this.Fr.zero,n.coefs[2],n.k);return a.push(r),[a,i]}processR1csMultiplicationConstraint(e,t,a,i){let n=[],r=[],o=this.reduceCoefs(e,n,r,t,1),l=this.reduceCoefs(e,n,r,a,1),s=this.reduceCoefs(e,n,r,i,1),u=this.fnGetMultiplicationConstraint(o.signals[0],l.signals[0],s.signals[0],this.Fr.mul(o.coefs[0],l.k),this.Fr.mul(o.k,l.coefs[0]),this.Fr.mul(o.coefs[0],l.coefs[0]),this.Fr.neg(s.coefs[0]),this.Fr.sub(this.Fr.mul(o.k,l.k),s.k));return n.push(u),[n,r]}}class e1{constructor(e,t,a){this.n=e,this.polynomials=Array(e).fill(void 0),this.curve=t,this.Fr=t.Fr,this.G1=t.G1,this.logger=a}addPolynomial(e,t){if(e>this.n-1)throw Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[e]=t}degree(){return Math.max(...this.polynomials.map((e,t)=>void 0===e?0:e.degree()*this.n+t))}getPolynomial(){let e=this.polynomials.map(e=>void 0===e?0:e.degree()),t=this.degree(),a=2**(B(t-1)+1),i=this.Fr.n8,r=new eM(new n.BigBuffer(a*i),this.curve,this.logger);for(let a=0;a<t;a++){let t=a*i,n=t*this.n;for(let o=0;o<this.n;o++)void 0!==this.polynomials[o]&&a<=e[o]&&r.coef.set(this.polynomials[o].coef.slice(t,t+i),n+o*i)}return r}async multiExponentiation(e,t){let a=this.getPolynomial(),i=a.coef.byteLength/this.Fr.n8,n=e.slice(0,i*this.G1.F.n8*2),r=await this.Fr.batchFromMontgomery(a.coef),o=await this.G1.multiExpAffine(n,r,this.logger,t);return this.G1.toAffine(o)}}let{stringifyBigInts:e0}=n.utils;async function e2(e,t,a){a&&a.info("FFLONK PROVER STARTED"),a&&a.info("> Reading witness file");let{fd:i,sections:r}=await g.readBinFile(t,"wtns",2,33554432,8388608),o=await Y(i,r);a&&a.info("> Reading zkey file");let{fd:l,sections:s}=await g.readBinFile(e,"zkey",2,33554432,8388608),u=await $(l,s);if(10!==u.protocolId)throw Error("zkey file is not fflonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!==u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let f=u.curve,d=f.Fr,c=f.Fr.n8,h=2*f.G1.F.n8,w=u.domainSize*c;a&&(a.info("----------------------------"),a.info("  FFLONK PROVE SETTINGS"),a.info(`  Curve:         ${f.name}`),a.info(`  Circuit power: ${u.power}`),a.info(`  Domain size:   ${u.domainSize}`),a.info(`  Vars:          ${u.nVars}`),a.info(`  Public vars:   ${u.nPublic}`),a.info(`  Constraints:   ${u.nConstraints}`),a.info(`  Additions:     ${u.nAdditions}`),a.info("----------------------------")),a&&a.info("> Reading witness file data");let m=await g.readSection(i,r,2);await i.close(),m.set(d.zero,0);let b=new n.BigBuffer(u.nAdditions*c),p={},v={},y={},S={},C={},F={},E=new ek(f,a);a&&a.info("> Reading Section 3. Additions"),await A(),a&&a.info("> Reading Sections 12,13,14. Sigma1, Sigma2 & Sigma 3"),a&&a.info("\xb7\xb7\xb7 Reading Sigma polynomials "),v.Sigma1=new eM(new n.BigBuffer(w),f,a),v.Sigma2=new eM(new n.BigBuffer(w),f,a),v.Sigma3=new eM(new n.BigBuffer(w),f,a),await l.readToBuffer(v.Sigma1.coef,0,w,s[12][0].p),await l.readToBuffer(v.Sigma2.coef,0,w,s[13][0].p),await l.readToBuffer(v.Sigma3.coef,0,w,s[14][0].p),a&&a.info("\xb7\xb7\xb7 Reading Sigma evaluations"),y.Sigma1=new eZ(new n.BigBuffer(4*w),f,a),y.Sigma2=new eZ(new n.BigBuffer(4*w),f,a),y.Sigma3=new eZ(new n.BigBuffer(4*w),f,a),await l.readToBuffer(y.Sigma1.eval,0,4*w,s[12][0].p+w),await l.readToBuffer(y.Sigma2.eval,0,4*w,s[13][0].p+w),await l.readToBuffer(y.Sigma3.eval,0,4*w,s[14][0].p+w),a&&a.info("> Reading Section 16. Powers of Tau");let x=new n.BigBuffer(16*u.domainSize*h);await l.readToBuffer(x,0,(9*u.domainSize+18)*h,s[16][0].p),globalThis.gc&&globalThis.gc(),a&&a.info(""),a&&a.info("> ROUND 1"),await z(),delete v.T0,delete y.QL,delete y.QR,delete y.QM,delete y.QO,delete y.QC,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 2"),await R(),delete p.A,delete p.B,delete p.C,delete y.A,delete y.B,delete y.C,delete y.Sigma1,delete y.Sigma2,delete y.Sigma3,delete y.lagrange1,delete y.Z,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 3"),await P(),delete v.A,delete v.B,delete v.C,delete v.Z,delete v.T1,delete v.T2,delete v.Sigma1,delete v.Sigma2,delete v.Sigma3,delete v.QL,delete v.QR,delete v.QM,delete v.QC,delete v.QO,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 4"),await G(),globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 5"),await U(),delete v.C0,delete v.C1,delete v.C2,delete v.R1,delete v.R2,delete v.F,delete v.L,delete v.ZT,delete v.ZTS2,await l.close(),globalThis.gc&&globalThis.gc(),E.addEvaluation("inv",function(){let e=C.xi;for(let t=0;t<u.power;t++)e=d.square(e);S.zh=d.sub(e,d.one),function(e,t,a,i){let n=i.Fr,r=t.length,o=n.mul(n.e(r),n.exp(t[0],r-2));for(let i=0;i<r;i++){let l=t[(r-1)*i%r],s=n.sub(a,t[i]);e[["LiS0_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(S,F.S0.h0w8,C.y,f),function(e,t,a,i){let n=i.Fr,r=t.length,o=n.mul(n.e(r),n.exp(t[0],r-2));for(let i=0;i<r;i++){let l=t[(r-1)*i%r],s=n.sub(a,t[i]);e[["LiS1_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(S,F.S1.h1w4,C.y,f),function(e,t,a,i,n,r,o){let l=o.Fr,s=l.mul(l.e(3),t[0]),u=l.sub(n,r),f=l.mul(s,u);for(let a=0;a<3;a++){let n=t[2*a%3],r=l.sub(i,t[a]);e[["LiS2_"+(a+1)]]=l.mul(f,l.mul(n,r))}let d=l.mul(l.e(3),a[0]),c=l.sub(r,n);f=l.mul(d,c);for(let t=0;t<3;t++){let n=a[2*t%3],r=l.sub(i,a[t]);e[["LiS2_"+(t+1+3)]]=l.mul(f,l.mul(n,r))}}(S,F.S2.h2w3,F.S2.h3w3,C.y,C.xi,C.xiw,f);let t=Math.max(1,u.nPublic),a=d.one;for(let e=0;e<t;e++)S["Li_"+(e+1)]=d.mul(d.e(u.domainSize),d.sub(C.xi,a)),a=d.mul(a,d.w[u.power]);let i=d.one;for(let e of Object.values(S))if(Array.isArray(e))for(let t of e)i=d.mul(i,t);else i=d.mul(i,e);return d.inv(i)}());let B=E.toObjectProof();B.protocol="fflonk",B.curve=f.name;let L=[];for(let e=1;e<=u.nPublic;e++){let t=e*c,a=m.slice(t,t+c);L.push(n.Scalar.fromRprLE(a))}return a&&a.info("FFLONK PROVER FINISHED"),{proof:e0(B),publicSignals:e0(L)};async function A(){a&&a.info("\xb7\xb7\xb7 Computing additions");let e=await g.readSection(l,s,3),t=8+2*c;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.info(`    addition ${i}/${u.nAdditions}`);let n=i*t,r=_(e,n);n+=4;let o=_(e,n);n+=4;let l=e.slice(n,n+c);n+=c;let s=e.slice(n,n+c),f=T(r),h=T(o),g=d.add(d.mul(l,f),d.mul(s,h));b.set(g,c*i)}}function _(e,t){let a=e.slice(t,t+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function T(e){let t=u.nVars-u.nAdditions;if(e<t)return m.slice(e*c,e*c+c);if(e<u.nVars){let a=(e-t)*c;return b.slice(a,a+c)}return d.zero}async function z(){C.b=[];for(let e=1;e<=9;e++)C.b[e]=d.random();a&&a.info("> Computing A, B, C wire polynomials"),await t(),a&&a.info("> Computing T0 polynomial"),await i(),a&&a.info("> Computing C1 polynomial"),await r(),a&&a.info("> Computing C1 multi exponentiation");let e=await v.C1.multiExponentiation(x,"C1");return E.addPolynomial("C1",e),0;async function t(){a&&a.info("\xb7\xb7\xb7 Reading data from zkey file"),p.A=new n.BigBuffer(w),p.B=new n.BigBuffer(w),p.C=new n.BigBuffer(w);let e=await g.readSection(l,s,4),t=await g.readSection(l,s,5),i=await g.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*c,r=4*a,o=_(e,r);p.A.set(T(o),n);let l=_(t,r);p.B.set(T(l),n);let s=_(i,r);p.C.set(T(s),n)}if(p.A.set(C.b[1],w-64),p.A.set(C.b[2],w-32),p.B.set(C.b[3],w-64),p.B.set(C.b[4],w-32),p.C.set(C.b[5],w-64),p.C.set(C.b[6],w-32),p.A=await d.batchToMontgomery(p.A),p.B=await d.batchToMontgomery(p.B),p.C=await d.batchToMontgomery(p.C),a&&a.info("\xb7\xb7\xb7 Computing A ifft"),v.A=await eM.fromEvaluations(p.A,f,a),a&&a.info("\xb7\xb7\xb7 Computing B ifft"),v.B=await eM.fromEvaluations(p.B,f,a),a&&a.info("\xb7\xb7\xb7 Computing C ifft"),v.C=await eM.fromEvaluations(p.C,f,a),a&&a.info("\xb7\xb7\xb7 Computing A fft"),y.A=await eZ.fromPolynomial(v.A,4,f,a),a&&a.info("\xb7\xb7\xb7 Computing B fft"),y.B=await eZ.fromPolynomial(v.B,4,f,a),a&&a.info("\xb7\xb7\xb7 Computing C fft"),y.C=await eZ.fromPolynomial(v.C,4,f,a),v.A.degree()>=u.domainSize)throw Error("A Polynomial is not well calculated");if(v.B.degree()>=u.domainSize)throw Error("B Polynomial is not well calculated");if(v.C.degree()>=u.domainSize)throw Error("C Polynomial is not well calculated")}async function i(){a&&a.info(`\xb7\xb7\xb7 Reading sections 7, 8, 9, 10, 11. Q selectors`),y.QL=new eZ(new n.BigBuffer(4*w),f,a),y.QR=new eZ(new n.BigBuffer(4*w),f,a),y.QM=new eZ(new n.BigBuffer(4*w),f,a),y.QO=new eZ(new n.BigBuffer(4*w),f,a),y.QC=new eZ(new n.BigBuffer(4*w),f,a),await l.readToBuffer(y.QL.eval,0,4*w,s[7][0].p+w),await l.readToBuffer(y.QR.eval,0,4*w,s[8][0].p+w),await l.readToBuffer(y.QM.eval,0,4*w,s[9][0].p+w),await l.readToBuffer(y.QO.eval,0,4*w,s[10][0].p+w),await l.readToBuffer(y.QC.eval,0,4*w,s[11][0].p+w);let e=await g.readSection(l,s,15);y.lagrange1=new eZ(e,f,a),p.T0=new n.BigBuffer(4*w),a&&a.info("\xb7\xb7\xb7 Computing T0 evaluations");for(let e=0;e<4*u.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`      T0 evaluation ${e}/${4*u.domainSize}`);let t=y.A.getEvaluation(e),i=y.B.getEvaluation(e),n=y.C.getEvaluation(e),r=y.QL.getEvaluation(e),o=y.QR.getEvaluation(e),l=y.QM.getEvaluation(e),s=y.QO.getEvaluation(e),f=y.QC.getEvaluation(e),h=d.zero;for(let t=0;t<u.nPublic;t++){let a=5*t*u.domainSize+u.domainSize+e,i=y.lagrange1.getEvaluation(a),n=p.A.slice(t*c,(t+1)*c);h=d.sub(h,d.mul(i,n))}let g=d.mul(t,r),w=d.mul(i,o),m=d.mul(d.mul(t,i),l),b=d.mul(n,s),v=d.add(g,d.add(w,d.add(m,d.add(b,d.add(f,h)))));p.T0.set(v,e*c)}if(a&&a.info("buffer T0: "+p.T0.byteLength/c),a&&a.info("\xb7\xb7\xb7 Computing T0 ifft"),v.T0=await eM.fromEvaluations(p.T0,f,a),a&&a.info("T0 length: "+v.T0.length()),a&&a.info("T0 degree: "+v.T0.degree()),a&&a.info("\xb7\xb7\xb7 Computing T0 / ZH"),v.T0.divByZerofier(u.domainSize,d.one),v.T0.degree()>=2*u.domainSize-2)throw Error(`T0 Polynomial is not well calculated (degree is ${v.T0.degree()} and must be less than ${2*u.domainSize+2}`);delete p.T0}async function r(){let e=new e1(4,f,a);if(e.addPolynomial(0,v.A),e.addPolynomial(1,v.B),e.addPolynomial(2,v.C),e.addPolynomial(3,v.T0),v.C1=e.getPolynomial(),v.C1.degree()>=8*u.domainSize-8)throw Error("C1 Polynomial is not well calculated")}}async function R(){a&&a.info("> Computing challenges beta and gamma");let e=new e$(f);e.addPolCommitment(u.C0);for(let t=0;t<u.nPublic;t++)e.addScalar(p.A.slice(t*c,t*c+c));e.addPolCommitment(E.getPolynomial("C1")),C.beta=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.beta: "+d.toString(C.beta)),e.reset(),e.addScalar(C.beta),C.gamma=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.gamma: "+d.toString(C.gamma)),a&&a.info("> Computing Z polynomial"),await i(),a&&a.info("> Computing T1 polynomial"),await r(),a&&a.info("> Computing T2 polynomial"),await o(),a&&a.info("> Computing C2 polynomial"),await l(),a&&a.info("> Computing C2 multi exponentiation");let t=await v.C2.multiExponentiation(x,"C2");return E.addPolynomial("C2",t),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing Z evaluations");let e=new n.BigBuffer(w),t=new n.BigBuffer(w);e.set(d.one,0),t.set(d.one,0);let i=d.one;for(let n=0;n<u.domainSize;n++){a&&0!==n&&n%1e5==0&&a.info(`    Z evaluation ${n}/${u.domainSize}`);let r=n*c,o=d.mul(C.beta,i),l=p.A.slice(r,r+c);l=d.add(l,o),l=d.add(l,C.gamma);let s=p.B.slice(r,r+c);s=d.add(s,d.mul(u.k1,o)),s=d.add(s,C.gamma);let f=p.C.slice(r,r+c);f=d.add(f,d.mul(u.k2,o)),f=d.add(f,C.gamma);let h=d.mul(l,d.mul(s,f)),g=p.A.slice(r,r+c);g=d.add(g,d.mul(C.beta,y.Sigma1.getEvaluation(4*n))),g=d.add(g,C.gamma);let w=p.B.slice(r,r+c);w=d.add(w,d.mul(C.beta,y.Sigma2.getEvaluation(4*n))),w=d.add(w,C.gamma);let m=p.C.slice(r,r+c);m=d.add(m,d.mul(C.beta,y.Sigma3.getEvaluation(4*n))),m=d.add(m,C.gamma);let b=d.mul(g,d.mul(w,m));h=d.mul(e.slice(r,r+c),h),e.set(h,(n+1)%u.domainSize*c),b=d.mul(t.slice(r,r+c),b),t.set(b,(n+1)%u.domainSize*c),i=d.mul(i,d.w[u.power])}t=await d.batchInverse(t);for(let a=0;a<u.domainSize;a++){let i=a*c,n=d.mul(e.slice(i,i+c),t.slice(i,i+c));e.set(n,i)}if(p.Z=e,!d.eq(e.slice(0,c),d.one))throw Error("Copy constraints does not match");if(a&&a.info("\xb7\xb7\xb7 Computing Z ifft"),v.Z=await eM.fromEvaluations(p.Z,f,a),a&&a.info("\xb7\xb7\xb7 Computing Z fft"),y.Z=await eZ.fromPolynomial(v.Z,4,f,a),v.Z.blindCoefficients([C.b[9],C.b[8],C.b[7]]),v.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete p.Z}async function r(){a&&a.info("\xb7\xb7\xb7 Computing T1 evaluations"),p.T1=new n.BigBuffer(2*w),p.T1z=new n.BigBuffer(2*w);let e=d.one;for(let t=0;t<2*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`    T1 evaluation ${t}/${4*u.domainSize}`);let i=d.square(e),n=y.Z.getEvaluation(2*t),r=d.add(d.add(d.mul(C.b[7],i),d.mul(C.b[8],e)),C.b[9]),o=y.lagrange1.getEvaluation(u.domainSize+2*t),l=d.mul(d.sub(n,d.one),o),s=d.mul(r,o);p.T1.set(l,t*c),p.T1z.set(s,t*c),e=d.mul(e,d.w[u.power+1])}if(a&&a.info("\xb7\xb7\xb7 Computing T1 ifft"),v.T1=await eM.fromEvaluations(p.T1,f,a),v.T1.divByZerofier(u.domainSize,d.one),a&&a.info("\xb7\xb7\xb7 Computing T1z ifft"),v.T1z=await eM.fromEvaluations(p.T1z,f,a),v.T1.add(v.T1z),v.T1.degree()>=u.domainSize+2)throw Error("T1 Polynomial is not well calculated");delete p.T1,delete p.T1z,delete v.T1z}async function o(){a&&a.info("\xb7\xb7\xb7 Computing T2 evaluations"),p.T2=new n.BigBuffer(4*w),p.T2z=new n.BigBuffer(4*w);let e=d.one;for(let t=0;t<4*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`    T2 evaluation ${t}/${4*u.domainSize}`);let i=d.square(e),n=d.mul(e,d.w[u.power]),r=d.square(n),o=y.A.getEvaluation(t),l=y.B.getEvaluation(t),s=y.C.getEvaluation(t),f=y.Z.getEvaluation(t),h=y.Z.getEvaluation((4*u.domainSize+4+t)%(4*u.domainSize)),g=d.add(d.add(d.mul(C.b[7],i),d.mul(C.b[8],e)),C.b[9]),w=d.add(d.add(d.mul(C.b[7],r),d.mul(C.b[8],n)),C.b[9]),m=y.Sigma1.getEvaluation(t),b=y.Sigma2.getEvaluation(t),v=y.Sigma3.getEvaluation(t),S=d.mul(C.beta,e),F=d.add(o,S);F=d.add(F,C.gamma);let E=d.add(l,d.mul(S,u.k1));E=d.add(E,C.gamma);let x=d.add(s,d.mul(S,u.k2));x=d.add(x,C.gamma);let B=d.mul(d.mul(d.mul(F,E),x),f),L=d.mul(d.mul(d.mul(F,E),x),g),A=d.add(o,d.mul(C.beta,m));A=d.add(A,C.gamma);let _=d.add(l,d.mul(C.beta,b));_=d.add(_,C.gamma);let T=d.add(s,d.mul(C.beta,v));T=d.add(T,C.gamma);let z=d.mul(d.mul(d.mul(A,_),T),h),R=d.mul(d.mul(d.mul(A,_),T),w),P=d.sub(B,z),G=d.sub(L,R);p.T2.set(P,t*c),p.T2z.set(G,t*c),e=d.mul(e,d.w[u.power+2])}if(a&&a.info("\xb7\xb7\xb7 Computing T2 ifft"),v.T2=await eM.fromEvaluations(p.T2,f,a),a&&a.info("\xb7\xb7\xb7 Computing T2 / ZH"),v.T2.divByZerofier(u.domainSize,d.one),a&&a.info("\xb7\xb7\xb7 Computing T2z ifft"),v.T2z=await eM.fromEvaluations(p.T2z,f,a),v.T2.add(v.T2z),v.T2.degree()>=3*u.domainSize)throw Error("T2 Polynomial is not well calculated");delete p.T2,delete p.T2z,delete v.T2z}async function l(){let e=new e1(3,f,a);if(e.addPolynomial(0,v.Z),e.addPolynomial(1,v.T1),e.addPolynomial(2,v.T2),v.C2=e.getPolynomial(),v.C2.degree()>=9*u.domainSize)throw Error("C2 Polynomial is not well calculated")}}async function P(){a&&a.info("> Computing challenge xi");let e=new e$(f);e.addScalar(C.gamma),e.addPolCommitment(E.getPolynomial("C2")),C.xiSeed=e.getChallenge();let t=d.square(C.xiSeed);F.w8=[],F.w8[0]=d.one;for(let e=1;e<8;e++)F.w8[e]=d.mul(F.w8[e-1],u.w8);F.w4=[],F.w4[0]=d.one;for(let e=1;e<4;e++)F.w4[e]=d.mul(F.w4[e-1],u.w4);F.w3=[],F.w3[0]=d.one,F.w3[1]=u.w3,F.w3[2]=d.square(u.w3),F.S0={},F.S0.h0w8=[],F.S0.h0w8[0]=d.mul(t,C.xiSeed);for(let e=1;e<8;e++)F.S0.h0w8[e]=d.mul(F.S0.h0w8[0],F.w8[e]);F.S1={},F.S1.h1w4=[],F.S1.h1w4[0]=d.square(F.S0.h0w8[0]);for(let e=1;e<4;e++)F.S1.h1w4[e]=d.mul(F.S1.h1w4[0],F.w4[e]);F.S2={},F.S2.h2w3=[],F.S2.h2w3[0]=d.mul(F.S1.h1w4[0],t),F.S2.h2w3[1]=d.mul(F.S2.h2w3[0],F.w3[1]),F.S2.h2w3[2]=d.mul(F.S2.h2w3[0],F.w3[2]),F.S2.h3w3=[],F.S2.h3w3[0]=d.mul(F.S2.h2w3[0],u.wr),F.S2.h3w3[1]=d.mul(F.S2.h3w3[0],F.w3[1]),F.S2.h3w3[2]=d.mul(F.S2.h3w3[0],F.w3[2]),C.xi=d.mul(d.square(F.S2.h2w3[0]),F.S2.h2w3[0]),a&&a.info("\xb7\xb7\xb7 challenges.xi: "+d.toString(C.xi)),v.QL=new eM(new n.BigBuffer(w),f,a),v.QR=new eM(new n.BigBuffer(w),f,a),v.QM=new eM(new n.BigBuffer(w),f,a),v.QO=new eM(new n.BigBuffer(w),f,a),v.QC=new eM(new n.BigBuffer(w),f,a),await l.readToBuffer(v.QL.coef,0,w,s[7][0].p),await l.readToBuffer(v.QR.coef,0,w,s[8][0].p),await l.readToBuffer(v.QM.coef,0,w,s[9][0].p),await l.readToBuffer(v.QO.coef,0,w,s[10][0].p),await l.readToBuffer(v.QC.coef,0,w,s[11][0].p),a&&a.info("\xb7\xb7\xb7 Computing evaluations"),E.addEvaluation("ql",v.QL.evaluate(C.xi)),E.addEvaluation("qr",v.QR.evaluate(C.xi)),E.addEvaluation("qm",v.QM.evaluate(C.xi)),E.addEvaluation("qo",v.QO.evaluate(C.xi)),E.addEvaluation("qc",v.QC.evaluate(C.xi)),E.addEvaluation("s1",v.Sigma1.evaluate(C.xi)),E.addEvaluation("s2",v.Sigma2.evaluate(C.xi)),E.addEvaluation("s3",v.Sigma3.evaluate(C.xi)),E.addEvaluation("a",v.A.evaluate(C.xi)),E.addEvaluation("b",v.B.evaluate(C.xi)),E.addEvaluation("c",v.C.evaluate(C.xi)),E.addEvaluation("z",v.Z.evaluate(C.xi)),C.xiw=d.mul(C.xi,d.w[u.power]),E.addEvaluation("zw",v.Z.evaluate(C.xiw)),E.addEvaluation("t1w",v.T1.evaluate(C.xiw)),E.addEvaluation("t2w",v.T2.evaluate(C.xiw))}async function G(){a&&a.info("> Computing challenge alpha");let e=new e$(f);e.addScalar(C.xiSeed),e.addScalar(E.getEvaluation("ql")),e.addScalar(E.getEvaluation("qr")),e.addScalar(E.getEvaluation("qm")),e.addScalar(E.getEvaluation("qo")),e.addScalar(E.getEvaluation("qc")),e.addScalar(E.getEvaluation("s1")),e.addScalar(E.getEvaluation("s2")),e.addScalar(E.getEvaluation("s3")),e.addScalar(E.getEvaluation("a")),e.addScalar(E.getEvaluation("b")),e.addScalar(E.getEvaluation("c")),e.addScalar(E.getEvaluation("z")),e.addScalar(E.getEvaluation("zw")),e.addScalar(E.getEvaluation("t1w")),e.addScalar(E.getEvaluation("t2w")),C.alpha=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.alpha: "+d.toString(C.alpha)),a&&a.info("> Reading C0 polynomial"),v.C0=new eM(new n.BigBuffer(8*w),f,a),await l.readToBuffer(v.C0.coef,0,8*w,s[17][0].p),a&&a.info("> Computing R0 polynomial"),function(){if(v.R0=eM.lagrangePolynomialInterpolation([F.S0.h0w8[0],F.S0.h0w8[1],F.S0.h0w8[2],F.S0.h0w8[3],F.S0.h0w8[4],F.S0.h0w8[5],F.S0.h0w8[6],F.S0.h0w8[7]],[v.C0.evaluate(F.S0.h0w8[0]),v.C0.evaluate(F.S0.h0w8[1]),v.C0.evaluate(F.S0.h0w8[2]),v.C0.evaluate(F.S0.h0w8[3]),v.C0.evaluate(F.S0.h0w8[4]),v.C0.evaluate(F.S0.h0w8[5]),v.C0.evaluate(F.S0.h0w8[6]),v.C0.evaluate(F.S0.h0w8[7])],f),v.R0.degree()>7)throw Error("R0 Polynomial is not well calculated")}(),a&&a.info("> Computing R1 polynomial"),function(){if(v.R1=eM.lagrangePolynomialInterpolation([F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3]],[v.C1.evaluate(F.S1.h1w4[0]),v.C1.evaluate(F.S1.h1w4[1]),v.C1.evaluate(F.S1.h1w4[2]),v.C1.evaluate(F.S1.h1w4[3])],f),v.R1.degree()>3)throw Error("R1 Polynomial is not well calculated")}(),a&&a.info("> Computing R2 polynomial"),function(){if(v.R2=eM.lagrangePolynomialInterpolation([F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],[v.C2.evaluate(F.S2.h2w3[0]),v.C2.evaluate(F.S2.h2w3[1]),v.C2.evaluate(F.S2.h2w3[2]),v.C2.evaluate(F.S2.h3w3[0]),v.C2.evaluate(F.S2.h3w3[1]),v.C2.evaluate(F.S2.h3w3[2])],f),v.R2.degree()>5)throw Error("R2 Polynomial is not well calculated")}(),a&&a.info("> Computing F polynomial"),await i(),a&&a.info("> Computing W1 multi exponentiation");let t=await v.F.multiExponentiation(x,"W1");return E.addPolynomial("W1",t),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing F polynomial"),v.F=eM.fromPolynomial(v.C0,f,a),v.F.sub(v.R0),v.F.divByZerofier(8,C.xi);let e=eM.fromPolynomial(v.C1,f,a);e.sub(v.R1),e.mulScalar(C.alpha),e.divByZerofier(4,C.xi);let t=eM.fromPolynomial(v.C2,f,a);if(t.sub(v.R2),t.mulScalar(d.square(C.alpha)),t.divByZerofier(3,C.xi),t.divByZerofier(3,C.xiw),v.F.add(e),v.F.add(t),v.F.degree()>=9*u.domainSize-6)throw Error("F Polynomial is not well calculated")}}async function U(){a&&a.info("> Computing challenge y");let e=new e$(f);e.addScalar(C.alpha),e.addPolCommitment(E.getPolynomial("W1")),C.y=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.y: "+d.toString(C.y)),a&&a.info("> Computing L polynomial"),await o(),a&&a.info("> Computing ZTS2 polynomial"),await s();let t=v.ZTS2.evaluate(C.y);t=d.inv(t),v.L.mulScalar(t);let i=eM.fromCoefficientsArray([d.neg(C.y),d.one],f);a&&a.info("> Computing W' = L / ZTS2 polynomial");let n=v.L.divBy(i);if(n.degree()>0)throw Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${n.degree()} and should be 0`);if(v.L.degree()>=9*u.domainSize-1)throw Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");a&&a.info("> Computing W' multi exponentiation");let r=await v.L.multiExponentiation(x,"W2");return E.addPolynomial("W2",r),0;async function o(){a&&a.info("\xb7\xb7\xb7 Computing L polynomial");let e=v.R0.evaluate(C.y),t=v.R1.evaluate(C.y),i=v.R2.evaluate(C.y),n=d.sub(C.y,F.S0.h0w8[0]);for(let e=1;e<8;e++)n=d.mul(n,d.sub(C.y,F.S0.h0w8[e]));let r=d.sub(C.y,F.S1.h1w4[0]);for(let e=1;e<4;e++)r=d.mul(r,d.sub(C.y,F.S1.h1w4[e]));let o=d.sub(C.y,F.S2.h2w3[0]);for(let e=1;e<3;e++)o=d.mul(o,d.sub(C.y,F.S2.h2w3[e]));for(let e=0;e<3;e++)o=d.mul(o,d.sub(C.y,F.S2.h3w3[e]));let s=d.mul(r,o),c=d.mul(C.alpha,d.mul(n,o)),h=d.mul(d.square(C.alpha),d.mul(n,r));S.denH1=r,S.denH2=o,v.L=eM.fromPolynomial(v.C0,f,a),v.L.subScalar(e),v.L.mulScalar(s);let g=eM.fromPolynomial(v.C1,f,a);g.subScalar(t),g.mulScalar(c);let w=eM.fromPolynomial(v.C2,f,a);w.subScalar(i),w.mulScalar(h),v.L.add(g),v.L.add(w),a&&a.info("> Computing ZT polynomial"),await l();let m=v.ZT.evaluate(C.y);if(v.F.mulScalar(m),v.L.sub(v.F),v.L.degree()>=9*u.domainSize)throw Error("L Polynomial is not well calculated");delete p.L}async function l(){v.ZT=eM.zerofierPolynomial([F.S0.h0w8[0],F.S0.h0w8[1],F.S0.h0w8[2],F.S0.h0w8[3],F.S0.h0w8[4],F.S0.h0w8[5],F.S0.h0w8[6],F.S0.h0w8[7],F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3],F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],f)}async function s(){v.ZTS2=eM.zerofierPolynomial([F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3],F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],f)}}}let{unstringifyBigInts:e8}=n.utils,{unstringifyBigInts:e3}=n.utils;function e4(e,t){return n.Scalar.lt(t,e.r)}function e7(e,t){return e4(e,n.Scalar.fromRprLE(t))}async function e6(e,t,a){let i=e.Fr,r=Math.max(1,a.nPublic),o=new n.BigBuffer(r*i.n8),l=new n.BigBuffer(r*i.n8),s=i.one;for(let e=0;e<r;e++){let n=e*i.n8;o.set(i.mul(s,t.zh),n),l.set(i.mul(i.e(a.domainSize),i.sub(t.xi,s)),n),s=i.mul(s,a.w)}l=await i.batchInverse(l);let u=[];for(let e=0;e<r;e++){let t=e*i.n8;u[e+1]=i.mul(o.slice(t,t+i.n8),l.slice(t,t+i.n8))}return u}async function e5(e,t,a,i,n,r,o){let l=e.G1,s=l.timesFr(t.polynomials.W2,a.y);s=l.add(l.sub(l.sub(n,r),o),s);let u=e.G2.one,f=t.polynomials.W2,d=i.X_2;return await e.pairingEq(l.neg(s),u,f,d)}function e9(e,t,a,i){let n=i.Fr,r=e.length,o=n.sub(n.exp(t,r),a),l=n.mul(n.e(r),n.exp(e[0],r-2)),s=[];for(let a=0;a<r;a++){let i=e[(r-1)*a%r],u=n.sub(t,e[a]);s[a]=n.div(o,n.mul(n.mul(l,i),u))}return s}let{unstringifyBigInts:te}=n.utils;t.tt=ed}}]);